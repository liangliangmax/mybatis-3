MyBatis的主要的核心部件有以下几个:

SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能
Executor              MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
StatementHandler      封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。
ParameterHandler      负责对用户传递的参数转换成JDBC Statement 所需要的参数，
ResultSetHandler      负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；
TypeHandler           负责java数据类型和jdbc数据类型之间的映射和转换
MappedStatement       MappedStatement维护了一条<select|update|delete|insert>节点的封装，
SqlSource             负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
BoundSql              表示动态生成的SQL语句以及相应的参数信息
Configuration         MyBatis所有的配置信息都维持在Configuration对象之中。



Application.main
    --> reader = Resources.getResourceAsReader("com/liang/Configuration.xml")
    --> sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader)
        --> SqlSessionFactoryBuilder.build(Reader reader, String environment, Properties properties)
            --> XMLConfigBuilder xmlConfigBuilder = new XMLConfigBuilder(reader, environment, properties)
                --> XMLConfigBuilder(Reader reader, String environment, Properties props)
                    --> this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props)

                        --> xmlMapperEntityResolver = new XMLMapperEntityResolver() //entityResolver比较好理解，跟Spring的XML标签解析器一样，有默认的解析器，也有自定义的比如tx，dubbo等，主要使用了策略模式，在这里mybatis硬编码为了XMLMapperEntityResolver

                        --> XPathParser = new XPathParser(reader, true, props, xmlMapperEntityResolver)
                            --> XPathParser.commonConstructor(validation, variables, entityResolver)
                                --> XPathParser  =  this.validation = validation;
                                                    this.entityResolver = entityResolver;
                                                    this.variables = variables;
                                                    XPathFactory factory = XPathFactory.newInstance();
                                                    this.xpath = factory.newXPath();
                            --> XPathParser.document = createDocument(InputSource(reader))
                                --> documentBuilderFactory = DocumentBuilderFactory.newInstance()
                                    --> FactoryFinder.find(DocumentBuilderFactory.class,"com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl")
                                        --> newInstance()
                                            --> return com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl

                                --> DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();

                                --> return builder.parse(inputSource) //主要是根据mybatis自身需要创建一个文档解析器，然后调用parse将输入input source解析为DOM XML文档并返回。
                                    --> DocumentBuilderImpl.parse(InputSource is)
                                        --> domParser.parse(is)
                                            -->DOMParser.parse(InputSource inputSource)
                                                --> parse(XMLInputSource inputSource)
                                                    --> XML11Configuration.parse(XMLInputSource)
                                                        --> parse(boolean complete)
                                                            -->  fCurrentScanner.scanDocument(complete)
                                                                --> XMLDocumentFragmentScannerImpl.scanDocument

                                        --> Document doc = domParser.getDocument();
                                        --> domParser.dropDocumentReferences();
                                        --> return doc


                        -->this(XPathParser, environment, props)
                            --> super(new Configuration());
                                --> BaseBuilder.this.configuration = configuration;
                                                this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();

                            --> ErrorContext.instance().resource("SQL Mapper Configuration");
                            --> this.configuration.setVariables(props);
                            --> this.parsed = false;
                            --> this.environment = environment;
                            --> this.parser = parser;

            --> configuration = xmlConfigBuilder.parse()
                --> XMLConfigBuilder.parse()
                    --> xNode = parser.evalNode("/configuration") //mybatis配置文件解析的主流程
                        --> XPathParser.evalNode("/configuration") //其中调用了parser.evalNode(“/configuration”)返回根节点的org.apache.ibatis.parsing.XNode表示
                            --> evalNode(null, "/configuration")
                                --> XPathImpl.evaluate(java.lang.String, java.lang.Object, javax.xml.namespace.QName)
                                    --> return new XNode(this, node, variables);

                    --> parseConfiguration(xNode) //根据mybatis的主要配置进行解析,所有的root.evalNode底层都是调用XML DOM的evaluate()方法，根据给定的节点表达式来计算指定的 XPath 表达式，并且返回一个XPathResult对象，返回类型在Node.evalNode()方法中均被指定为NODE。
                            //解析properties的方法
                            //首先加载properties节点下的property属性，然后从url或resource加载配置文件，都先和configuration.variables合并，然后赋值到XMLConfigBuilder.parser和BaseBuilder.configuration。此时开始所有的属性就可以在随后的整个配置文件中使用了。
                        --> propertiesElement(root.evalNode("properties"));
                            --> Properties defaults = context.getChildrenAsProperties(); // 从配置文件中读取<properties>节点的属性
                                Properties vars = configuration.getVariables();
                                defaults.putAll(vars);
                                parser.setVariables(defaults); // 为xparser变量赋值，
                                configuration.setVariables(defaults); //为configuration 变量赋值

                            //首先加载settings下面的setting节点为property，然后检查所有属性,确保它们都在Configuration中已定义，而非未知的设置。
                            //注：MetaClass是一个保存对象定义比如getter/setter/构造器等的元数据类,localReflectorFactory则是mybatis提供的默认反射工厂实现，
                            //这个ReflectorFactory主要采用了工厂类，其内部使用的Reflector采用了facade设计模式，简化反射的使用。
                        --> Properties settings = settingsAsProperties(root.evalNode("settings")); //得到setting之后，调用settingsElement(Properties props)将各值赋值给configuration，
                            --> Properties props = context.getChildrenAsProperties(); //获取xml文件中的配置节点信息
                                MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory); // 检查所有从settings加载的设置,确保它们都在Configuration定义的范围内，就是别出现configuration类中没有的属性。同时在这里有重新设置了默认值，所有这一点很重要，configuration中的默认值不一定是真正的默认值。
                                return props;


                            // VFS主要用来加载容器内的各种资源，比如jar或者class文件。
                        --> loadCustomVfs(settings);
                            --> configuration.setVfsImpl(vfsImpl); //从配置文件中读取配置的实现类，然后将其进行实例化

                        --> loadCustomLogImpl(settings);
                            --> configuration.setLogImpl(logImpl); //从配置文件中读取配置的日志实现类，然后将其进行实例化

                            //解析类型别名typeAliasesElement,mybatis主要提供两种类型的别名设置，具体类的别名以及包的别名设置。类型别名是为 Java 类型设置一个短的名字，存在的意义仅在于用来减少类完全限定名的冗余。
                        --> typeAliasesElement(root.evalNode("typeAliases"));
                            --> typeAliasRegistry.registerAlias(alias, clazz)
                                --> Map<String, Class<?>> typeAliases = new HashMap<>()
                                    typeAliases.put(alias, clazz); //将配置文件中的自定义类型添加到map中，除此之外，还自动注册了一些基本类型和少许的复杂类型

                            //加载插件pluginElement,插件在具体实现的时候，采用的是拦截器模式，要注册为mybatis插件，必须实现org.apache.ibatis.plugin.Interceptor接口，每个插件可以有自己的属性。 interceptor属性值既可以完整的类名，也可以是别名，只要别名在typealias中存在即可，实例化插件后，将设置插件的属性赋值给插件实现类的属性字段
                        --> pluginElement(root.evalNode("plugins"));
                            --> Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
                                Properties properties = child.getChildrenAsProperties(); //从配置文件中读取的<plugin>标签下面的property标签的属性
                                interceptorInstance.setProperties(properties);
                                configuration.addInterceptor(interceptorInstance); // 为configuration添加插件

                            //加载对象工厂objectFactoryElement,MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂DefaultObjectFactory做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化
                        --> objectFactoryElement(root.evalNode("objectFactory"));
                            --> Properties properties = context.getChildrenAsProperties(); //从配置文件中读取的<objectFactory>标签下面的property标签的属性
                                ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
                                factory.setProperties(properties);
                                configuration.setObjectFactory(factory);


                            //创建对象包装器工厂objectWrapperFactoryElement,对象包装器工厂主要用来包装返回result对象，比如说可以用来设置某些敏感字段脱敏或者加密等
                        --> objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
                            --> ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).newInstance();
                                configuration.setObjectWrapperFactory(factory);

                            //加载反射工厂reflectorFactoryElement，因为加载配置文件中的各种插件类等等，为了提供更好的灵活性，mybatis支持用户自定义反射工厂，默认的反射工厂是DefaultReflectorFactory
                        --> reflectorFactoryElement(root.evalNode("reflectorFactory"));
                            --> ReflectorFactory factory = (ReflectorFactory) resolveClass(type).newInstance();
                                configuration.setReflectorFactory(factory);

                            //将配置文件中<settings>标签解析出来的settings付给configuration类，所以之前要检查配置的属性是否在configuration类中
                        --> settingsElement(settings);
                            --> configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
                                configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
                                configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
                                configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
                                configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty("lazyLoadingEnabled"), false));
                                configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty("aggressiveLazyLoading"), false));
                                configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty("multipleResultSetsEnabled"), true));
                                configuration.setUseColumnLabel(booleanValueOf(props.getProperty("useColumnLabel"), true));
                                configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty("useGeneratedKeys"), false));
                                configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty("defaultExecutorType", "SIMPLE")));
                                .
                                .
                                .

                            // read it after objectFactory and objectWrapperFactory issue #631
                            //加载环境配置environmentsElement,环境可以说是mybatis-config配置文件中最重要的部分，它类似于spring和maven里面的profile，
                            //允许给开发、生产环境同时配置不同的environment，根据不同的环境加载不同的配置，这也是常见的做法，
                            //事务管理器和数据源类型这里都用到了类型别名，JDBC/POOLED都是在mybatis内置提供的，在Configuration构造器执行期间注册到TypeAliasRegister。
                            //如果在SqlSessionFactoryBuilder调用期间没有传递使用哪个环境的话，默认会使用一个名为default”的环境。找到对应的environment之后，就可以加载事务管理器和数据源了。
                        --> environmentsElement(root.evalNode("environments"));
                            --> TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager")); // 事务配置并创建事务工厂
                                --> TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance();
                                    Properties props = context.getChildrenAsProperties();
                                    factory.setProperties(props);
                                    return factory;
                            --> DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource")); // 数据源配置加载并实例化数据源, 数据源是必备的
                                --> Properties props = context.getChildrenAsProperties();
                                    DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();
                                    factory.setProperties(props);
                                    return factory;

                            --> Environment.Builder environmentBuilder = new Environment.Builder(id).transactionFactory(txFactory).dataSource(dataSource);
                            --> configuration.setEnvironment(environmentBuilder.build());

                            //数据库厂商标识加载databaseIdProviderElement,MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。
                        --> databaseIdProviderElement(root.evalNode("databaseIdProvider"));
                            --> String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());
                                configuration.setDatabaseId(databaseId);

                            //加载类型处理器typeHandlerElement,无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。
                            //为了简化使用，mybatis在初始化TypeHandlerRegistry期间，自动注册了大部分的常用的类型处理器比如字符串、数字、日期等。对于非标准的类型，用户可以自定义类型处理器来处理。要实现一个自定义类型处理器，只要实现 org.apache.ibatis.type.TypeHandler 接口，或继承一个实用类 org.apache.ibatis.type.BaseTypeHandler， 并将它映射到一个 JDBC 类型即可。
                        --> typeHandlerElement(root.evalNode("typeHandlers"));
                            --> String javaTypeName = child.getStringAttribute("javaType");
                                String jdbcTypeName = child.getStringAttribute("jdbcType");
                                String handlerTypeName = child.getStringAttribute("handler");
                                Class<?> javaTypeClass = resolveClass(javaTypeName);
                                JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
                                Class<?> typeHandlerClass = resolveClass(handlerTypeName);
                                typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
                                --> allTypeHandlersMap.put(handler.getClass(), handler);

                            //加载mapper文件mapperElement
                            //mapper文件是mybatis框架的核心之处，所有的用户sql语句都编写在mapper文件中，
                            //mybatis提供了两类配置mapper的方法，第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper，
                            //另外一类是明确指定mapper，这又可以通过resource、url或者class进行细分。

                            //对于通过package加载的mapper文件，调用mapperRegistry.addMappers(packageName);进行加载，其核心逻辑在org.apache.ibatis.binding.MapperRegistry中，对于每个找到的接口或者mapper文件，最后调用用XMLMapperBuilder进行具体解析。
                            //对于明确指定的mapper文件或者mapper接口，则主要使用XMLMapperBuilder进行具体解析。
                        --> mapperElement(root.evalNode("mappers"));
                            --> String resource = child.getStringAttribute("resource"); //com/liang/mapper/UserMapper.xml
                            --> InputStream inputStream = Resources.getResourceAsStream(resource);
                            --> XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
                                --> xmlMapperEntityResolver = new XMLMapperEntityResolver()
                                --> XPathParser = new XPathParser(inputStream, true, configuration.getVariables(), xmlMapperEntityResolver)
                                --> this(XPathParser,configuration, resource, sqlFragments);
                                    -->this.configuration = configuration;
                                       this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                       this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();
                                       this.builderAssistant = new MapperBuilderAssistant(configuration, resource);
                                       --> this.resource = resource;
                                       this.parser = parser;
                                       this.sqlFragments = sqlFragments;
                                       this.resource = resource;

                            --> mapperParser.parse();
                                --> XMLMapperBuilder.parse()
                                    --> configuration.isResourceLoaded(resource)
                                        --> Set<String> loadedResources = new HashSet<>();
                                            return loadedResources.contains(resource);

                                    --> configurationElement(parser.evalNode("/mapper"));
                                        --> String namespace = context.getStringAttribute("namespace"); //com.liang.UserMapper
                                        --> builderAssistant.setCurrentNamespace("com.liang.UserMapper")

                                            //解析缓存参照cache-ref。参照缓存顾名思义，就是共用其他缓存的设置。
                                        --> cacheRefElement(context.evalNode("cache-ref"));
                                            --> cacheRefMap.put(namespace, referencedNamespace);

                                            --> CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute("namespace"));
                                            --> cacheRefResolver.resolveCacheRef()
                                                --> assistant.useCacheRef(cacheRefNamespace)
                                                    --> return cache = configuration.getCache("com.liang.UserMapper");

                                            //解析缓存cache,默认情况下，mybatis使用的是永久缓存PerpetualCache，读取或设置各个属性默认值之后，调用builderAssistant.useNewCache构建缓存，其中的CacheBuilder使用了build模式（在effective里面，建议有4个以上可选属性时，应该为对象提供一个builder便于使用），只要实现org.apache.ibatis.cache.Cache接口，就是合法的mybatis缓存。
                                        --> cacheElement(context.evalNode("cache"));
                                            --> builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
                                                --> Cache cache = new CacheBuilder(currentNamespace)
                                                            .implementation(valueOrDefault(typeClass, PerpetualCache.class))
                                                            .addDecorator(valueOrDefault(evictionClass, LruCache.class))
                                                            .clearInterval(flushInterval)
                                                            .size(size)
                                                            .readWrite(readWrite)
                                                            .blocking(blocking)
                                                            .properties(props)
                                                            .build();
                                                    configuration.addCache(cache);


                                            //解析参数映射parameterMap
                                        --> parameterMapElement(context.evalNodes("/mapper/parameterMap"));

                                            //解析结果集映射resultMap,每个mapper文件可以有多个结果集映射
                                        --> resultMapElements(context.evalNodes("/mapper/resultMap"));
                                            --> resultMapElement(resultMapNode, Collections.emptyList(), null)
                                                --> resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType)
                                                    --> String type = resultMapNode.getStringAttribute("type",
                                                            resultMapNode.getStringAttribute("ofType",
                                                                resultMapNode.getStringAttribute("resultType",
                                                                    resultMapNode.getStringAttribute("javaType")))); // com.liang.User
                                                    --> Class<?> typeClass = resolveClass(type); //class com.liang.User

                                                    //所有下的最底层子元素比如<id>,<result> 等本质上都属于一个映射,只不过有着额外的标记比如是否嵌套，是否构造器等。
                                                    //总体逻辑是先解析resultMap节点本身，然后解析子节点构造器，鉴别器discriminator，id。最后组装成真正的resultMappings。
                                                    //resultMap里面可以包含多种子节点，每个节点都有具体的方法进行解析，这也体现了单一职责原则。
                                                    //在resultMapElement中，主要是解析resultMap节点本身并循环遍历委托给具体的方法处理。

                                                    --> resultMap = buildResultMappingFromContext(resultChild, typeClass, flags)
                                                        --> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy)
                                                    --> resultMappings.add(resultMap)

                                                    --> ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
                                                    --> resultMapResolver.resolve()
                                                        --> ResultMap resultMap = new ResultMap.Builder(configuration, "com.liang.UserMapper.baseResult", "class com.liang.User", resultMappings, null)
                                                                    .discriminator(discriminator)
                                                                    .build();
                                                        --> configuration.addResultMap(resultMap);

                                            //解析<sql id=”userColumns”> id,username,password </sql>这样的句子
                                        --> sqlElement(context.evalNodes("/mapper/sql"));
                                            --> sqlFragments.put("com.liang.UserMapper.userColumns", context);

                                            //INSERT/UPDATE/DELETE属于一种类型,SELECT为一种类型
                                        --> buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
                                            --> buildStatementFromContext(list, null)
                                                --> final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
                                                    --> this.builderAssistant = builderAssistant;
                                                        this.context = context;
                                                        this.requiredDatabaseId = databaseId;
                                                        this.configuration = configuration;
                                                        this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                        this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();

                                                    //总的来说，将节点分为文本节点、include、非include三类进行处理。
                                                    //对于include节点：根据属性refid调用findSqlFragment找到sql片段，对节点中包含的占位符进行替换解析，然后调用自身进行递归解析，解析到文本节点返回之后。
                                                    //判断下include的sql片段是否和包含它的节点是同一个文档，
                                                    //如果不是，则把它从原来的文档包含进来。
                                                    //然后使用include指向的sql节点替换include节点，最后剥掉sql节点本身，也就是把sql下的节点上移一层，这样就合法了。
                                                --> statementParser.parseStatementNode();
                                                    --> String id = context.getStringAttribute("id"); // getUserById
                                                    --> String nodeName = context.getNode().getNodeName(); // select
                                                    --> boolean isSelect = sqlCommandType == SqlCommandType.SELECT; // true
                                                    --> boolean flushCache = context.getBooleanAttribute("flushCache", !isSelect); //false  insert/delete/update后是否刷新缓存
                                                    --> boolean useCache = context.getBooleanAttribute("useCache", isSelect); // true   select是否使用缓存
                                                    --> XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
                                                        --> this.configuration = configuration;
                                                            this.MapperBuilderAssistant = builderAssistant;

                                                    --> includeParser.applyIncludes(context.getNode());
                                                        --> XMLIncludeTransformer.applyIncludes(org.w3c.dom.Node)
                                                            --> applyIncludes(Node source, final Properties variablesContext, boolean included)

                                                    --> String parameterType = context.getStringAttribute("parameterType"); //String
                                                    --> Class<?> parameterTypeClass = resolveClass(parameterType);

                                                        //处理返回id
                                                    --> processSelectKeyNodes(id, parameterTypeClass, langDriver);
                                                        --> List<XNode> selectKeyNodes = context.evalNodes("selectKey"); // selectKey返回最近一次插入的id
                                                        --> parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);
                                                            -->  String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;
                                                                 String databaseId = nodeToHandle.getStringAttribute("databaseId");
                                                                 parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);
                                                                 --> builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
                                                                             fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
                                                                             resultSetTypeEnum, flushCache, useCache, resultOrdered,
                                                                             keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);

                                                                 --> configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));

                                                        --> removeSelectKeyNodes(selectKeyNodes);


                                                    --> String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; // getUserById!selectKey

                                                    --> keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); // com.liang.UserMapper.getUserById!selectKey

                                                    --> keyGenerator = context.getBooleanAttribute("useGeneratedKeys",
                                                                 configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))
                                                                 ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE; // NoKeyGenerator

                                                        // 根据XML定义创建SqlSource
                                                    --> SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
                                                        --> XMLLanguageDriver.createSqlSource(Configuration, XNode, Class)
                                                            --> XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
                                                                -->this.configuration = configuration;
                                                                   this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                                   this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();
                                                                   this.context = context;
                                                                   this.parameterType = parameterType;

                                                                   initNodeHandlerMap()
                                                                   --> nodeHandlerMap.put("trim", new TrimHandler());
                                                                       nodeHandlerMap.put("where", new WhereHandler());
                                                                       nodeHandlerMap.put("set", new SetHandler());
                                                                       nodeHandlerMap.put("foreach", new ForEachHandler());
                                                                       nodeHandlerMap.put("if", new IfHandler());
                                                                       nodeHandlerMap.put("choose", new ChooseHandler());
                                                                       nodeHandlerMap.put("when", new IfHandler());
                                                                       nodeHandlerMap.put("otherwise", new OtherwiseHandler());
                                                                       nodeHandlerMap.put("bind", new BindHandler());

                                                               /**
                                                               * 因为给DynamicContext()构造器传递的parameterObject为空,所以没有参数，也不需要反射，反之就通过反射将object转为map。
                                                               * 因为rootSqlNode是StaticTextSqlNode类型，所以getSql就直接返回原文本，随后调用第二个构造器，
                                                               * 首先创建一个SqlSourceBuilder实例，然后调用其parse()方法，
                                                               * 其中ParameterMappingTokenHandler符号处理器的目的是把sql参数解析出来，
                                                               */
                                                            --> return builder.parseScriptNode()
                                                                --> MixedSqlNode rootSqlNode = parseDynamicTags(context);
                                                                    --> String data = child.getStringBody(""); //select id,username,password from user where id = #{id}
                                                                    --> TextSqlNode textSqlNode = new TextSqlNode(data);
                                                                    --> if textSqlNode.isDynamic() // 判断文本节点中是否包含了${}，如果包含则为动态文本节点，否则为静态文本节点(包括#{})，静态文本节点在运行时不需要二次处理
                                                                        --> new GenericTokenParser("${", "}", handler);

                                                                    --> contents.add(new StaticTextSqlNode(data));
                                                                    --> return new MixedSqlNode(contents);

                                                                --> sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); //静态sql
                                                                    --> sql = getSql(configuration, rootSqlNode)
                                                                        --> DynamicContext context = new DynamicContext(configuration, null);
                                                                            --> bindings = new ContextMap(null, false);
                                                                                --> this.parameterMetaObject = parameterMetaObject;
                                                                                    this.fallbackParameterObject = fallbackParameterObject;

                                                                            --> bindings.put("_parameter", parameterObject);
                                                                                bindings.put("_databaseId", configuration.getDatabaseId());

                                                                        --> rootSqlNode.apply(context);

                                                                        --> return context.getSql();
                                                                            --> sqlBuilder.toString().trim()

                                                                    --> this(configuration, sql, parameterType)
                                                                        --> Class<?> clazz = parameterType == null ? Object.class : parameterType; // class java.lang.String
                                                                        --> sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap<>());
                                                                            --> ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);
                                                                                --> this.parameterType = parameterType;
                                                                                    this.metaParameters = configuration.newMetaObject(additionalParameters);

                                                                            --> GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);

                                                                            --> String sql = parser.parse(originalSql);
                                                                                --> builder.append(handler.handleToken(expression.toString()));
                                                                                    --> return "?";
                                                                                --> return select id,username,password from user where id = ?

                                                                            --> return new StaticSqlSource(configuration, sql, handler.getParameterMappings());
                                                                                --> this.sql = sql;
                                                                                    this.parameterMappings = parameterMappings;
                                                                                    this.configuration = configuration;


                                                    --> StatementType statementType = StatementType.valueOf(context.getStringAttribute("statementType", StatementType.PREPARED.toString())); //PREPARED
                                                    --> Integer fetchSize = context.getIntAttribute("fetchSize");
                                                    --> Integer timeout = context.getIntAttribute("timeout");
                                                    --> String parameterMap = context.getStringAttribute("parameterMap"); // null
                                                    --> String resultType = context.getStringAttribute("resultType"); //com.liang.User
                                                    --> Class<?> resultTypeClass = resolveClass(resultType); // class com.liang.User
                                                    --> String resultMap = context.getStringAttribute("resultMap"); // null

                                                    --> builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
                                                            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
                                                            resultSetTypeEnum, flushCache, useCache, resultOrdered,
                                                            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
                                                        --> MapperBuilderAssistant.addMappedStatement(String id,
                                                                                                       SqlSource sqlSource,
                                                                                                       StatementType statementType,
                                                                                                       SqlCommandType sqlCommandType,
                                                                                                       Integer fetchSize,
                                                                                                       Integer timeout,
                                                                                                       String parameterMap,
                                                                                                       Class<?> parameterType,
                                                                                                       String resultMap,
                                                                                                       Class<?> resultType,
                                                                                                       ResultSetType resultSetType,
                                                                                                       boolean flushCache,
                                                                                                       boolean useCache,
                                                                                                       boolean resultOrdered,
                                                                                                       KeyGenerator keyGenerator,
                                                                                                       String keyProperty,
                                                                                                       String keyColumn,
                                                                                                       String databaseId,
                                                                                                       LanguageDriver lang,
                                                                                                       String resultSets)

                                                            --> id = applyCurrentNamespace(id, false); // com.liang.UserMapper.getUserById
                                                            --> boolean isSelect = sqlCommandType == SqlCommandType.SELECT; // true
                                                            --> MappedStatement.Builder statementBuilder = new MappedStatement.Builder(.........)(太多了)
                                                            --> ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
                                                                --> parameterTypeClass != null
                                                                --> parameterMap = new ParameterMap.Builder(
                                                                              configuration,
                                                                              statementId + "-Inline", // com.liang.UserMapper.getUserById-Inline
                                                                              parameterTypeClass,       // class java.lang.String
                                                                              parameterMappings).build();

                                                            --> statementBuilder.parameterMap(statementParameterMap);
                                                                --> assert mappedStatement.configuration != null;
                                                                    assert mappedStatement.id != null;
                                                                    assert mappedStatement.sqlSource != null;
                                                                    assert mappedStatement.lang != null;
                                                                    mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps);

                                                            --> MappedStatement statement = statementBuilder.build(); // 此处会将xml生成mappedStatement

                                                            --> configuration.addMappedStatement(statement);    //将MappedStatement添加到configuration中
                                                                --> mappedStatements.put(ms.getId(), ms); // key:com.liang.UserMapper.getUserById，value:statement

                                    --> configuration.addLoadedResource(resource);
                                        --> loadedResources.add("com/liang/mapper/UserMapper.xml"); //标识已经添加了

                                        //将namespace从xml中解析出来，然后进行类绑定
                                    --> bindMapperForNamespace();
                                        --> String namespace = builderAssistant.getCurrentNamespace(); // com.liang.UserMapper
                                        --> Class<?> boundType = Resources.classForName(namespace);
                                        --> configuration.addLoadedResource("namespace:" + namespace); // "namespace:com.liang.UserMapper"
                                        --> configuration.addMapper(boundType);
                                            --> mapperRegistry.addMapper(type);
                                                --> if (type.isInterface()) // 对于mybatis mapper接口文件，必须是interface，不能是class
                                                --> if (hasMapper(type))  // 判重，确保只会加载一次不会被覆盖

                                                    // 为mapper接口创建一个MapperProxyFactory代理
                                                    // knownMappers是MapperRegistry的主要字段，
                                                    // 维护了Mapper接口和代理类的映射关系,key是mapper接口类，value是MapperProxyFactory
                                                --> private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();

                                                --> mapperProxyFactory = new MapperProxyFactory<>(type)
                                                        //从定义看出，MapperProxyFactory主要是维护mapper接口的方法与对应mapper文件中具体CRUD节点的关联关系。
                                                        // 其中每个Method与对应MapperMethod维护在一起。MapperMethod是mapper中具体映射语句节点的内部表示
                                                    --> private final Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<>();
                                                    --> this.mapperInterface = mapperInterface;

                                                --> knownMappers.put(type, mapperProxyFactory);//key:interface com.liang.UserMapper; value:mapperProxyFactory

                                                --> MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                                                    --> String resource = type.getName().replace('.', '/') + ".java (best guess)"; // com/liang/UserMapper.java (best guess)
                                                    --> this.assistant = new MapperBuilderAssistant(configuration, resource);
                                                    --> this.configuration = configuration;
                                                    --> this.type = type;

                                                    //MapperBuilderAssistant初始化完成之后，就调用build.parse()进行具体的mapper接口文件加载与解析
                                                    /**
                                                       *整体流程为：
                                                       * 1、首先加载mapper接口对应的xml文件并解析。
                                                       * loadXmlResource和通过resource、url解析相同，都是解析mapper文件中的定义，他们的入口都是XMLMapperBuilder.parse()，
                                                       * 我们稍等会儿专门专门分析，这一节先来看通过注解方式配置的mapper的解析
                                                       * （注：对于一个mapper接口,不能同时使用注解方式和xml方式,任何时候只能之一,但是不同的mapper接口可以混合使用这两种方式）。
                                                       *
                                                       * 2、解析缓存注解；
                                                       * 3、解析缓存参照注解。
                                                       * 4、解析非桥接方法。在正式开始之前，我们先来看下什么是桥接方法。
                                                       * 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。
                                                       * 那什么时候，编译器会生成桥接方法呢，
                                                       * 举个例子，一个子类在继承（或实现）一个父类（或接口）的泛型方法时，在子类中明确指定了泛型类型，
                                                       * 那么在编译时编译器会自动生成桥接方法。
                                                       * 所以正常情况下，只要在实现mybatis mapper接口的时候，没有继承根Mapper或者继承了根Mapper但是没有写死泛型类型的时候，是不会成为桥接方法的。
                                                       * 现在来看parseStatement的主要实现代码(提示:因为注解方式通常不用于复杂的配置,所以这里我们进行简单的解析，在XML部分进行详细说明)：
                                                       */
                                                --> parser.parse();
                                                    --> String resource = type.toString(); //interface com.liang.UserMapper

                                                        /**
                                                           * 根据package自动搜索加载的时候，约定俗称从classpath下加载接口的完整名，
                                                           * 比如org.mybatis.example.mapper.BlogMapper，就加载org/mybatis/example/mapper/BlogMapper.xml。
                                                           * 对于从package和class进来的mapper，如果找不到对应的文件，就忽略，
                                                           * 因为这种情况下是允许SQL语句作为注解打在接口上的，所以xml文件不是必须的，
                                                           * 而对于直接声明的xml mapper文件，如果找不到的话会抛出IOException异常而终止，这在使用注解模式的时候需要注意。
                                                           * 加载到对应的mapper.xml文件后，调用XMLMapperBuilder进行解析。
                                                           *
                                                           * 在创建XMLMapperBuilder时，我们发现用到了configuration.getSqlFragments()，
                                                           * 这就是我们在mapper文件中经常使用的可以被包含在其他语句中的SQL片段，但是我们并没有初始化过，
                                                           * 所以很有可能它是在解析过程中动态添加的，创建了XMLMapperBuilder之后，在调用其parse()接口进行具体xml的解析，
                                                           * 这和mybatis-config的逻辑基本上是一致的思路

                                                           其实之前已经加载过xml文件了，所以configuration类中其实已经有了这个namespace了，
                                                           */
                                                    --> loadXmlResource()
                                                        --> if !configuration.isResourceLoaded("namespace:" + type.getName())
                                                        --> String xmlResource = type.getName().replace('.', '/') + ".xml";
                                                        --> InputStream inputStream = type.getResourceAsStream("/" + xmlResource);
                                                        --> XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
                                                        --> xmlParser.parse();

                                                    --> configuration.addLoadedResource(resource);

                                                    --> assistant.setCurrentNamespace("interface com.liang.UserMapper");

                                                        //添加注解的情况
                                                    --> parseCache();
                                                        --> CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);
                                                        --> assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);

                                                        //添加注解的情况
                                                    --> parseCacheRef();
                                                        --> CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);
                                                        --> assistant.useCacheRef(namespace);

                                                    --> Method[] methods = type.getMethods();

                                                        //添加注解的情况
                                                        // 获取参数类型,如果有多个参数,这种情况下就返回org.apache.ibatis.binding.MapperMethod.ParamMap.class，
                                                        // ParamMap是一个继承于HashMap的类，否则返回实际类型
                                                    --> parseStatement("public abstract com.liang.User com.liang.UserMapper.getUserById(java.lang.String)");
                                                        --> Class<?> parameterTypeClass = getParameterType(method);
                                                            --> Class<?>[] parameterTypes = method.getParameterTypes(); // class java.lang.String

                                                            //获取方法的SqlSource对象,只有指定了@Select/@Insert/@Update/@Delete或者对应的Provider的方法才会被当作mapper,否则只是和mapper文件中对应语句的一个运行时占位符
                                                        --> SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver); // null 从注解上面解析出来的sql语句
                                                            --> assistant.addMappedStatement(mappedStatementId,
                                                                                                       sqlSource,
                                                                                                       statementType,
                                                                                                       sqlCommandType,
                                                                                                       fetchSize,
                                                                                                       timeout,
                                                                                                       // ParameterMapID
                                                                                                       null,
                                                                                                       parameterTypeClass,
                                                                                                       resultMapId,
                                                                                                       getReturnType(method),
                                                                                                       resultSetType,
                                                                                                       flushCache,
                                                                                                       useCache,
                                                                                                       false,
                                                                                                       keyGenerator,
                                                                                                       keyProperty,
                                                                                                       keyColumn,
                                                                                                       // DatabaseID
                                                                                                       null,
                                                                                                       languageDriver,
                                                                                                       // ResultSets
                                                                                                       options != null ? nullOrEmpty(options.resultSets()) : null);

                                                    --> parsePendingMethods()
                                                            //将所有configuration类中没有完成的方法都取出来，然后在执行一遍
                                                        --> Collection<MethodResolver> incompleteMethods = configuration.getIncompleteMethods();
                                                        --> iter.next().resolve();
                                                        --> iter.remove();


                                    --> parsePendingResultMaps();
                                            //将所有configuration类中没有完成的resultMap都取出来，然后在执行一遍
                                        --> Collection<ResultMapResolver> incompleteResultMaps = configuration.getIncompleteResultMaps();
                                        --> iter.next().resolve();
                                        --> iter.remove();

                                    --> parsePendingCacheRefs();
                                            //将所有configuration类中没有完成的cacheRefs都取出来，然后在执行一遍
                                        --> Collection<CacheRefResolver> incompleteCacheRefs = configuration.getIncompleteCacheRefs();
                                        --> iter.next().resolveCacheRef();
                                        --> iter.remove();

                                    --> parsePendingStatements();
                                        //将所有configuration类中没有完成的statement都取出来，然后在执行一遍
                                        --> Collection<XMLStatementBuilder> incompleteStatements = configuration.getIncompleteStatements();
                                        --> iter.next().parseStatementNode();
                                        --> iter.remove();

            --> return build(configuration)
                --> return new DefaultSqlSessionFactory(config);

    --> SqlSession sqlSession = sqlSessionFactory.openSession();

    --> List<User> list = sqlSession.selectList("com.liang.UserMapper.getUsers");

    --> sqlSession.close();