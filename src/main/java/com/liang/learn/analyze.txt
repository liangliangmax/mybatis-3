MyBatis的主要的核心部件有以下几个:

SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能
Executor              MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
StatementHandler      封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。
ParameterHandler      负责对用户传递的参数转换成JDBC Statement 所需要的参数，
ResultSetHandler      负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；
TypeHandler           负责java数据类型和jdbc数据类型之间的映射和转换
MappedStatement       MappedStatement维护了一条<select|update|delete|insert>节点的封装，
SqlSource             负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
BoundSql              表示动态生成的SQL语句以及相应的参数信息
Configuration         MyBatis所有的配置信息都维持在Configuration对象之中。



Application.main
    --> reader = Resources.getResourceAsReader("com/liang/Configuration.xml")
    --> sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader)
        --> SqlSessionFactoryBuilder.build(Reader reader, String environment, Properties properties)
            --> XMLConfigBuilder xmlConfigBuilder = new XMLConfigBuilder(reader, environment, properties)
                --> XMLConfigBuilder(Reader reader, String environment, Properties props)
                    --> this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props)

                        --> xmlMapperEntityResolver = new XMLMapperEntityResolver() //entityResolver比较好理解，跟Spring的XML标签解析器一样，有默认的解析器，也有自定义的比如tx，dubbo等，主要使用了策略模式，在这里mybatis硬编码为了XMLMapperEntityResolver

                        --> XPathParser = new XPathParser(reader, true, props, xmlMapperEntityResolver)
                            --> XPathParser.commonConstructor(validation, variables, entityResolver)
                                --> XPathParser  =  this.validation = validation;
                                                    this.entityResolver = entityResolver;
                                                    this.variables = variables;
                                                    XPathFactory factory = XPathFactory.newInstance();
                                                    this.xpath = factory.newXPath();
                            --> XPathParser.document = createDocument(InputSource(reader))
                                --> documentBuilderFactory = DocumentBuilderFactory.newInstance()
                                    --> FactoryFinder.find(DocumentBuilderFactory.class,"com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl")
                                        --> newInstance()
                                            --> return com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl

                                --> DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();

                                --> return builder.parse(inputSource) //主要是根据mybatis自身需要创建一个文档解析器，然后调用parse将输入input source解析为DOM XML文档并返回。
                                    --> DocumentBuilderImpl.parse(InputSource is)
                                        --> domParser.parse(is)
                                            -->DOMParser.parse(InputSource inputSource)
                                                --> parse(XMLInputSource inputSource)
                                                    --> XML11Configuration.parse(XMLInputSource)
                                                        --> parse(boolean complete)
                                                            -->  fCurrentScanner.scanDocument(complete)
                                                                --> XMLDocumentFragmentScannerImpl.scanDocument

                                        --> Document doc = domParser.getDocument();
                                        --> domParser.dropDocumentReferences();
                                        --> return doc


                        -->this(XPathParser, environment, props)
                            --> super(new Configuration());
                                --> BaseBuilder.this.configuration = configuration;
                                                this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();

                            --> ErrorContext.instance().resource("SQL Mapper Configuration");
                            --> this.configuration.setVariables(props);
                            --> this.parsed = false;
                            --> this.environment = environment;
                            --> this.parser = parser;

            --> configuration = xmlConfigBuilder.parse()
                --> XMLConfigBuilder.parse()
                    --> xNode = parser.evalNode("/configuration") //mybatis配置文件解析的主流程
                        --> XPathParser.evalNode("/configuration") //其中调用了parser.evalNode(“/configuration”)返回根节点的org.apache.ibatis.parsing.XNode表示
                            --> evalNode(null, "/configuration")
                                --> XPathImpl.evaluate(java.lang.String, java.lang.Object, javax.xml.namespace.QName)
                                    --> return new XNode(this, node, variables);

                    --> parseConfiguration(xNode) //根据mybatis的主要配置进行解析,所有的root.evalNode底层都是调用XML DOM的evaluate()方法，根据给定的节点表达式来计算指定的 XPath 表达式，并且返回一个XPathResult对象，返回类型在Node.evalNode()方法中均被指定为NODE。
                            //解析properties的方法
                            //首先加载properties节点下的property属性，然后从url或resource加载配置文件，都先和configuration.variables合并，然后赋值到XMLConfigBuilder.parser和BaseBuilder.configuration。此时开始所有的属性就可以在随后的整个配置文件中使用了。
                        --> propertiesElement(root.evalNode("properties"));
                            --> Properties defaults = context.getChildrenAsProperties(); // 从配置文件中读取<properties>节点的属性
                                Properties vars = configuration.getVariables();
                                defaults.putAll(vars);
                                parser.setVariables(defaults); // 为xparser变量赋值，
                                configuration.setVariables(defaults); //为configuration 变量赋值

                            //首先加载settings下面的setting节点为property，然后检查所有属性,确保它们都在Configuration中已定义，而非未知的设置。
                            //注：MetaClass是一个保存对象定义比如getter/setter/构造器等的元数据类,localReflectorFactory则是mybatis提供的默认反射工厂实现，
                            //这个ReflectorFactory主要采用了工厂类，其内部使用的Reflector采用了facade设计模式，简化反射的使用。
                        --> Properties settings = settingsAsProperties(root.evalNode("settings")); //得到setting之后，调用settingsElement(Properties props)将各值赋值给configuration，
                            --> Properties props = context.getChildrenAsProperties(); //获取xml文件中的配置节点信息
                                MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory); // 检查所有从settings加载的设置,确保它们都在Configuration定义的范围内，就是别出现configuration类中没有的属性。同时在这里有重新设置了默认值，所有这一点很重要，configuration中的默认值不一定是真正的默认值。
                                return props;


                            // VFS主要用来加载容器内的各种资源，比如jar或者class文件。
                        --> loadCustomVfs(settings);
                            --> configuration.setVfsImpl(vfsImpl); //从配置文件中读取配置的实现类，然后将其进行实例化

                        --> loadCustomLogImpl(settings);
                            --> configuration.setLogImpl(logImpl); //从配置文件中读取配置的日志实现类，然后将其进行实例化

                            //解析类型别名typeAliasesElement,mybatis主要提供两种类型的别名设置，具体类的别名以及包的别名设置。类型别名是为 Java 类型设置一个短的名字，存在的意义仅在于用来减少类完全限定名的冗余。
                        --> typeAliasesElement(root.evalNode("typeAliases"));
                            --> typeAliasRegistry.registerAlias(alias, clazz)
                                --> Map<String, Class<?>> typeAliases = new HashMap<>()
                                    typeAliases.put(alias, clazz); //将配置文件中的自定义类型添加到map中，除此之外，还自动注册了一些基本类型和少许的复杂类型

                            //加载插件pluginElement,插件在具体实现的时候，采用的是拦截器模式，要注册为mybatis插件，必须实现org.apache.ibatis.plugin.Interceptor接口，每个插件可以有自己的属性。 interceptor属性值既可以完整的类名，也可以是别名，只要别名在typealias中存在即可，实例化插件后，将设置插件的属性赋值给插件实现类的属性字段
                        --> pluginElement(root.evalNode("plugins"));
                            --> Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
                                Properties properties = child.getChildrenAsProperties(); //从配置文件中读取的<plugin>标签下面的property标签的属性
                                interceptorInstance.setProperties(properties);
                                configuration.addInterceptor(interceptorInstance); // 为configuration添加插件

                            //加载对象工厂objectFactoryElement,MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂DefaultObjectFactory做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化
                        --> objectFactoryElement(root.evalNode("objectFactory"));
                            --> Properties properties = context.getChildrenAsProperties(); //从配置文件中读取的<objectFactory>标签下面的property标签的属性
                                ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
                                factory.setProperties(properties);
                                configuration.setObjectFactory(factory);


                            //创建对象包装器工厂objectWrapperFactoryElement,对象包装器工厂主要用来包装返回result对象，比如说可以用来设置某些敏感字段脱敏或者加密等
                        --> objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
                            --> ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).newInstance();
                                configuration.setObjectWrapperFactory(factory);

                            //加载反射工厂reflectorFactoryElement，因为加载配置文件中的各种插件类等等，为了提供更好的灵活性，mybatis支持用户自定义反射工厂，默认的反射工厂是DefaultReflectorFactory
                        --> reflectorFactoryElement(root.evalNode("reflectorFactory"));
                            --> ReflectorFactory factory = (ReflectorFactory) resolveClass(type).newInstance();
                                configuration.setReflectorFactory(factory);

                            //将配置文件中<settings>标签解析出来的settings付给configuration类，所以之前要检查配置的属性是否在configuration类中
                        --> settingsElement(settings);
                            --> configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
                                configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
                                configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
                                configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
                                configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty("lazyLoadingEnabled"), false));
                                configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty("aggressiveLazyLoading"), false));
                                configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty("multipleResultSetsEnabled"), true));
                                configuration.setUseColumnLabel(booleanValueOf(props.getProperty("useColumnLabel"), true));
                                configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty("useGeneratedKeys"), false));
                                configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty("defaultExecutorType", "SIMPLE")));
                                .
                                .
                                .

                            // read it after objectFactory and objectWrapperFactory issue #631
                            //加载环境配置environmentsElement,环境可以说是mybatis-config配置文件中最重要的部分，它类似于spring和maven里面的profile，
                            //允许给开发、生产环境同时配置不同的environment，根据不同的环境加载不同的配置，这也是常见的做法，
                            //事务管理器和数据源类型这里都用到了类型别名，JDBC/POOLED都是在mybatis内置提供的，在Configuration构造器执行期间注册到TypeAliasRegister。
                            //如果在SqlSessionFactoryBuilder调用期间没有传递使用哪个环境的话，默认会使用一个名为default”的环境。找到对应的environment之后，就可以加载事务管理器和数据源了。
                        --> environmentsElement(root.evalNode("environments"));
                            --> TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager")); // 事务配置并创建事务工厂
                                --> TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance();
                                    Properties props = context.getChildrenAsProperties();
                                    factory.setProperties(props);
                                    return factory;
                            --> DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource")); // 数据源配置加载并实例化数据源, 数据源是必备的
                                --> Properties props = context.getChildrenAsProperties();
                                    DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();
                                    factory.setProperties(props);
                                    return factory;

                            --> Environment.Builder environmentBuilder = new Environment.Builder(id).transactionFactory(txFactory).dataSource(dataSource);
                            --> configuration.setEnvironment(environmentBuilder.build());

                            //数据库厂商标识加载databaseIdProviderElement,MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。
                        --> databaseIdProviderElement(root.evalNode("databaseIdProvider"));
                            --> String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());
                                configuration.setDatabaseId(databaseId);

                            //加载类型处理器typeHandlerElement,无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。
                            //为了简化使用，mybatis在初始化TypeHandlerRegistry期间，自动注册了大部分的常用的类型处理器比如字符串、数字、日期等。对于非标准的类型，用户可以自定义类型处理器来处理。要实现一个自定义类型处理器，只要实现 org.apache.ibatis.type.TypeHandler 接口，或继承一个实用类 org.apache.ibatis.type.BaseTypeHandler， 并将它映射到一个 JDBC 类型即可。
                        --> typeHandlerElement(root.evalNode("typeHandlers"));
                            --> String javaTypeName = child.getStringAttribute("javaType");
                                String jdbcTypeName = child.getStringAttribute("jdbcType");
                                String handlerTypeName = child.getStringAttribute("handler");
                                Class<?> javaTypeClass = resolveClass(javaTypeName);
                                JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
                                Class<?> typeHandlerClass = resolveClass(handlerTypeName);
                                typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
                                --> allTypeHandlersMap.put(handler.getClass(), handler);

                            //加载mapper文件mapperElement
                            //mapper文件是mybatis框架的核心之处，所有的用户sql语句都编写在mapper文件中，
                            //mybatis提供了两类配置mapper的方法，第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper，
                            //另外一类是明确指定mapper，这又可以通过resource、url或者class进行细分。

                            //对于通过package加载的mapper文件，调用mapperRegistry.addMappers(packageName);进行加载，其核心逻辑在org.apache.ibatis.binding.MapperRegistry中，对于每个找到的接口或者mapper文件，最后调用用XMLMapperBuilder进行具体解析。
                            //对于明确指定的mapper文件或者mapper接口，则主要使用XMLMapperBuilder进行具体解析。
                        --> mapperElement(root.evalNode("mappers"));
                            --> String resource = child.getStringAttribute("resource"); //com/liang/mapper/UserMapper.xml
                            --> InputStream inputStream = Resources.getResourceAsStream(resource);
                            --> XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
                                --> xmlMapperEntityResolver = new XMLMapperEntityResolver()
                                --> XPathParser = new XPathParser(inputStream, true, configuration.getVariables(), xmlMapperEntityResolver)
                                --> this(XPathParser,configuration, resource, sqlFragments);
                                    -->this.configuration = configuration;
                                       this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                       this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();
                                       this.builderAssistant = new MapperBuilderAssistant(configuration, resource);
                                       --> this.resource = resource;
                                       this.parser = parser;
                                       this.sqlFragments = sqlFragments;
                                       this.resource = resource;

                            --> mapperParser.parse();
                                --> XMLMapperBuilder.parse()
                                    --> configuration.isResourceLoaded(resource)
                                        --> Set<String> loadedResources = new HashSet<>();
                                            return loadedResources.contains(resource);

                                    --> configurationElement(parser.evalNode("/mapper"));
                                        --> String namespace = context.getStringAttribute("namespace"); //com.liang.UserMapper
                                        --> builderAssistant.setCurrentNamespace("com.liang.UserMapper")

                                            //解析缓存参照cache-ref。参照缓存顾名思义，就是共用其他缓存的设置。
                                        --> cacheRefElement(context.evalNode("cache-ref"));
                                            --> cacheRefMap.put(namespace, referencedNamespace);

                                            --> CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute("namespace"));
                                            --> cacheRefResolver.resolveCacheRef()
                                                --> assistant.useCacheRef(cacheRefNamespace)
                                                    --> return cache = configuration.getCache("com.liang.UserMapper");

                                            //解析缓存cache,默认情况下，mybatis使用的是永久缓存PerpetualCache，读取或设置各个属性默认值之后，调用builderAssistant.useNewCache构建缓存，其中的CacheBuilder使用了build模式（在effective里面，建议有4个以上可选属性时，应该为对象提供一个builder便于使用），只要实现org.apache.ibatis.cache.Cache接口，就是合法的mybatis缓存。
                                        --> cacheElement(context.evalNode("cache"));
                                            --> builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
                                                --> Cache cache = new CacheBuilder(currentNamespace)
                                                            .implementation(valueOrDefault(typeClass, PerpetualCache.class))
                                                            .addDecorator(valueOrDefault(evictionClass, LruCache.class))
                                                            .clearInterval(flushInterval)
                                                            .size(size)
                                                            .readWrite(readWrite)
                                                            .blocking(blocking)
                                                            .properties(props)
                                                            .build();
                                                    configuration.addCache(cache);


                                            //解析参数映射parameterMap
                                        --> parameterMapElement(context.evalNodes("/mapper/parameterMap"));

                                            //解析结果集映射resultMap,每个mapper文件可以有多个结果集映射
                                        --> resultMapElements(context.evalNodes("/mapper/resultMap"));
                                            --> resultMapElement(resultMapNode, Collections.emptyList(), null)
                                                --> resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType)
                                                    --> String type = resultMapNode.getStringAttribute("type",
                                                            resultMapNode.getStringAttribute("ofType",
                                                                resultMapNode.getStringAttribute("resultType",
                                                                    resultMapNode.getStringAttribute("javaType")))); // com.liang.User
                                                    --> Class<?> typeClass = resolveClass(type); //class com.liang.User

                                                    //所有下的最底层子元素比如<id>,<result> 等本质上都属于一个映射,只不过有着额外的标记比如是否嵌套，是否构造器等。
                                                    //总体逻辑是先解析resultMap节点本身，然后解析子节点构造器，鉴别器discriminator，id。最后组装成真正的resultMappings。
                                                    //resultMap里面可以包含多种子节点，每个节点都有具体的方法进行解析，这也体现了单一职责原则。
                                                    //在resultMapElement中，主要是解析resultMap节点本身并循环遍历委托给具体的方法处理。

                                                    --> resultMap = buildResultMappingFromContext(resultChild, typeClass, flags)
                                                        --> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy)
                                                    --> resultMappings.add(resultMap)

                                                    --> ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
                                                    --> resultMapResolver.resolve()
                                                        --> ResultMap resultMap = new ResultMap.Builder(configuration, "com.liang.UserMapper.baseResult", "class com.liang.User", resultMappings, null)
                                                                    .discriminator(discriminator)
                                                                    .build();
                                                        --> configuration.addResultMap(resultMap);

                                            //解析<sql id=”userColumns”> id,username,password </sql>这样的句子
                                        --> sqlElement(context.evalNodes("/mapper/sql"));
                                            --> sqlFragments.put("com.liang.UserMapper.userColumns", context);

                                            //INSERT/UPDATE/DELETE属于一种类型,SELECT为一种类型
                                        --> buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
                                            --> buildStatementFromContext(list, null)
                                                --> final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
                                                    --> this.builderAssistant = builderAssistant;
                                                        this.context = context;
                                                        this.requiredDatabaseId = databaseId;
                                                        this.configuration = configuration;
                                                        this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                        this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();

                                                    //总的来说，将节点分为文本节点、include、非include三类进行处理。
                                                    //对于include节点：根据属性refid调用findSqlFragment找到sql片段，对节点中包含的占位符进行替换解析，然后调用自身进行递归解析，解析到文本节点返回之后。
                                                    //判断下include的sql片段是否和包含它的节点是同一个文档，
                                                    //如果不是，则把它从原来的文档包含进来。
                                                    //然后使用include指向的sql节点替换include节点，最后剥掉sql节点本身，也就是把sql下的节点上移一层，这样就合法了。
                                                --> statementParser.parseStatementNode();
                                                    --> String id = context.getStringAttribute("id"); // getUserById
                                                    --> String nodeName = context.getNode().getNodeName(); // select
                                                    --> boolean isSelect = sqlCommandType == SqlCommandType.SELECT; // true
                                                    --> boolean flushCache = context.getBooleanAttribute("flushCache", !isSelect); //false  insert/delete/update后是否刷新缓存
                                                    --> boolean useCache = context.getBooleanAttribute("useCache", isSelect); // true   select是否使用缓存
                                                    --> XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
                                                        --> this.configuration = configuration;
                                                            this.MapperBuilderAssistant = builderAssistant;

                                                    --> includeParser.applyIncludes(context.getNode());
                                                        --> XMLIncludeTransformer.applyIncludes(org.w3c.dom.Node)
                                                            --> applyIncludes(Node source, final Properties variablesContext, boolean included)

                                                    --> String parameterType = context.getStringAttribute("parameterType"); //String
                                                    --> Class<?> parameterTypeClass = resolveClass(parameterType);

                                                        //处理返回id
                                                    --> processSelectKeyNodes(id, parameterTypeClass, langDriver);
                                                        --> List<XNode> selectKeyNodes = context.evalNodes("selectKey"); // selectKey返回最近一次插入的id
                                                        --> parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);
                                                            -->  String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;
                                                                 String databaseId = nodeToHandle.getStringAttribute("databaseId");
                                                                 parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);
                                                                 --> builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
                                                                             fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
                                                                             resultSetTypeEnum, flushCache, useCache, resultOrdered,
                                                                             keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);

                                                                 --> configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));

                                                        --> removeSelectKeyNodes(selectKeyNodes);


                                                    --> String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; // getUserById!selectKey

                                                    --> keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); // com.liang.UserMapper.getUserById!selectKey

                                                    --> keyGenerator = context.getBooleanAttribute("useGeneratedKeys",
                                                                 configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))
                                                                 ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE; // NoKeyGenerator

                                                        // 根据XML定义创建SqlSource
                                                    --> SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
                                                        --> XMLLanguageDriver.createSqlSource(Configuration, XNode, Class)
                                                            --> XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
                                                                -->this.configuration = configuration;
                                                                   this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                                   this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();
                                                                   this.context = context;
                                                                   this.parameterType = parameterType;

                                                                   initNodeHandlerMap()
                                                                   --> nodeHandlerMap.put("trim", new TrimHandler());
                                                                       nodeHandlerMap.put("where", new WhereHandler());
                                                                       nodeHandlerMap.put("set", new SetHandler());
                                                                       nodeHandlerMap.put("foreach", new ForEachHandler());
                                                                       nodeHandlerMap.put("if", new IfHandler());
                                                                       nodeHandlerMap.put("choose", new ChooseHandler());
                                                                       nodeHandlerMap.put("when", new IfHandler());
                                                                       nodeHandlerMap.put("otherwise", new OtherwiseHandler());
                                                                       nodeHandlerMap.put("bind", new BindHandler());

                                                               /**
                                                               * 因为给DynamicContext()构造器传递的parameterObject为空,所以没有参数，也不需要反射，反之就通过反射将object转为map。
                                                               * 因为rootSqlNode是StaticTextSqlNode类型，所以getSql就直接返回原文本，随后调用第二个构造器，
                                                               * 首先创建一个SqlSourceBuilder实例，然后调用其parse()方法，
                                                               * 其中ParameterMappingTokenHandler符号处理器的目的是把sql参数解析出来，
                                                               */
                                                            --> return builder.parseScriptNode()
                                                                --> MixedSqlNode rootSqlNode = parseDynamicTags(context);
                                                                    --> String data = child.getStringBody(""); //select id,username,password from user where id = #{id}
                                                                    --> TextSqlNode textSqlNode = new TextSqlNode(data);
                                                                    --> if textSqlNode.isDynamic() // 判断文本节点中是否包含了${}，如果包含则为动态文本节点，否则为静态文本节点(包括#{})，静态文本节点在运行时不需要二次处理
                                                                        --> new GenericTokenParser("${", "}", handler);

                                                                    --> contents.add(new StaticTextSqlNode(data));
                                                                    --> return new MixedSqlNode(contents);

                                                                --> sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); //静态sql
                                                                    --> sql = getSql(configuration, rootSqlNode)
                                                                        --> DynamicContext context = new DynamicContext(configuration, null);
                                                                            --> bindings = new ContextMap(null, false);
                                                                                --> this.parameterMetaObject = parameterMetaObject;
                                                                                    this.fallbackParameterObject = fallbackParameterObject;

                                                                            --> bindings.put("_parameter", parameterObject);
                                                                                bindings.put("_databaseId", configuration.getDatabaseId());

                                                                        --> rootSqlNode.apply(context);

                                                                        --> return context.getSql();
                                                                            --> sqlBuilder.toString().trim()

                                                                    --> this(configuration, sql, parameterType)
                                                                        --> Class<?> clazz = parameterType == null ? Object.class : parameterType; // class java.lang.String
                                                                        --> sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap<>());
                                                                            --> ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);
                                                                                --> this.parameterType = parameterType;
                                                                                    this.metaParameters = configuration.newMetaObject(additionalParameters);

                                                                            --> GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);

                                                                            --> String sql = parser.parse(originalSql);
                                                                                --> builder.append(handler.handleToken(expression.toString()));
                                                                                    --> return "?";
                                                                                --> return select id,username,password from user where id = ?

                                                                            --> return new StaticSqlSource(configuration, sql, handler.getParameterMappings());
                                                                                --> this.sql = sql;
                                                                                    this.parameterMappings = parameterMappings;
                                                                                    this.configuration = configuration;


                                                    --> StatementType statementType = StatementType.valueOf(context.getStringAttribute("statementType", StatementType.PREPARED.toString())); //PREPARED
                                                    --> Integer fetchSize = context.getIntAttribute("fetchSize");
                                                    --> Integer timeout = context.getIntAttribute("timeout");
                                                    --> String parameterMap = context.getStringAttribute("parameterMap"); // null
                                                    --> String resultType = context.getStringAttribute("resultType"); //com.liang.User
                                                    --> Class<?> resultTypeClass = resolveClass(resultType); // class com.liang.User
                                                    --> String resultMap = context.getStringAttribute("resultMap"); // null

                                                    --> builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
                                                            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
                                                            resultSetTypeEnum, flushCache, useCache, resultOrdered,
                                                            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
                                                        --> MapperBuilderAssistant.addMappedStatement(String id,
                                                                                                       SqlSource sqlSource,
                                                                                                       StatementType statementType,
                                                                                                       SqlCommandType sqlCommandType,
                                                                                                       Integer fetchSize,
                                                                                                       Integer timeout,
                                                                                                       String parameterMap,
                                                                                                       Class<?> parameterType,
                                                                                                       String resultMap,
                                                                                                       Class<?> resultType,
                                                                                                       ResultSetType resultSetType,
                                                                                                       boolean flushCache,
                                                                                                       boolean useCache,
                                                                                                       boolean resultOrdered,
                                                                                                       KeyGenerator keyGenerator,
                                                                                                       String keyProperty,
                                                                                                       String keyColumn,
                                                                                                       String databaseId,
                                                                                                       LanguageDriver lang,
                                                                                                       String resultSets)

                                                            --> id = applyCurrentNamespace(id, false); // com.liang.UserMapper.getUserById
                                                            --> boolean isSelect = sqlCommandType == SqlCommandType.SELECT; // true
                                                            --> MappedStatement.Builder statementBuilder = new MappedStatement.Builder(.........)(太多了)
                                                            --> ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
                                                                --> parameterTypeClass != null
                                                                --> parameterMap = new ParameterMap.Builder(
                                                                              configuration,
                                                                              statementId + "-Inline", // com.liang.UserMapper.getUserById-Inline
                                                                              parameterTypeClass,       // class java.lang.String
                                                                              parameterMappings).build();

                                                            --> statementBuilder.parameterMap(statementParameterMap);
                                                                --> assert mappedStatement.configuration != null;
                                                                    assert mappedStatement.id != null;
                                                                    assert mappedStatement.sqlSource != null;
                                                                    assert mappedStatement.lang != null;
                                                                    mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps);

                                                            --> MappedStatement statement = statementBuilder.build(); // 此处会将xml生成mappedStatement

                                                            --> configuration.addMappedStatement(statement);    //将MappedStatement添加到configuration中
                                                                --> mappedStatements.put(ms.getId(), ms); // key:com.liang.UserMapper.getUserById，value:statement

                                    --> configuration.addLoadedResource(resource);
                                        --> loadedResources.add("com/liang/mapper/UserMapper.xml"); //标识已经添加了

                                        //将namespace从xml中解析出来，然后进行类绑定
                                    --> bindMapperForNamespace();
                                        --> String namespace = builderAssistant.getCurrentNamespace(); // com.liang.UserMapper
                                        --> Class<?> boundType = Resources.classForName(namespace);
                                        --> configuration.addLoadedResource("namespace:" + namespace); // "namespace:com.liang.UserMapper"
                                        --> configuration.addMapper(boundType);
                                            --> mapperRegistry.addMapper(type);
                                                --> if (type.isInterface()) // 对于mybatis mapper接口文件，必须是interface，不能是class
                                                --> if (hasMapper(type))  // 判重，确保只会加载一次不会被覆盖

                                                    // 为mapper接口创建一个MapperProxyFactory代理
                                                    // knownMappers是MapperRegistry的主要字段，
                                                    // 维护了Mapper接口和代理类的映射关系,key是mapper接口类，value是MapperProxyFactory
                                                --> private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();

                                                --> mapperProxyFactory = new MapperProxyFactory<>(type)
                                                        //从定义看出，MapperProxyFactory主要是维护mapper接口的方法与对应mapper文件中具体CRUD节点的关联关系。
                                                        // 其中每个Method与对应MapperMethod维护在一起。MapperMethod是mapper中具体映射语句节点的内部表示
                                                    --> private final Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<>();
                                                    --> this.mapperInterface = mapperInterface;

                                                --> knownMappers.put(type, mapperProxyFactory);//key:interface com.liang.UserMapper; value:mapperProxyFactory

                                                --> MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                                                    --> String resource = type.getName().replace('.', '/') + ".java (best guess)"; // com/liang/UserMapper.java (best guess)
                                                    --> this.assistant = new MapperBuilderAssistant(configuration, resource);
                                                    --> this.configuration = configuration;
                                                    --> this.type = type;

                                                    //MapperBuilderAssistant初始化完成之后，就调用build.parse()进行具体的mapper接口文件加载与解析
                                                    /**
                                                       *整体流程为：
                                                       * 1、首先加载mapper接口对应的xml文件并解析。
                                                       * loadXmlResource和通过resource、url解析相同，都是解析mapper文件中的定义，他们的入口都是XMLMapperBuilder.parse()，
                                                       * 我们稍等会儿专门专门分析，这一节先来看通过注解方式配置的mapper的解析
                                                       * （注：对于一个mapper接口,不能同时使用注解方式和xml方式,任何时候只能之一,但是不同的mapper接口可以混合使用这两种方式）。
                                                       *
                                                       * 2、解析缓存注解；
                                                       * 3、解析缓存参照注解。
                                                       * 4、解析非桥接方法。在正式开始之前，我们先来看下什么是桥接方法。
                                                       * 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法。
                                                       * 那什么时候，编译器会生成桥接方法呢，
                                                       * 举个例子，一个子类在继承（或实现）一个父类（或接口）的泛型方法时，在子类中明确指定了泛型类型，
                                                       * 那么在编译时编译器会自动生成桥接方法。
                                                       * 所以正常情况下，只要在实现mybatis mapper接口的时候，没有继承根Mapper或者继承了根Mapper但是没有写死泛型类型的时候，是不会成为桥接方法的。
                                                       * 现在来看parseStatement的主要实现代码(提示:因为注解方式通常不用于复杂的配置,所以这里我们进行简单的解析，在XML部分进行详细说明)：
                                                       */
                                                --> parser.parse();
                                                    --> String resource = type.toString(); //interface com.liang.UserMapper

                                                        /**
                                                           * 根据package自动搜索加载的时候，约定俗称从classpath下加载接口的完整名，
                                                           * 比如org.mybatis.example.mapper.BlogMapper，就加载org/mybatis/example/mapper/BlogMapper.xml。
                                                           * 对于从package和class进来的mapper，如果找不到对应的文件，就忽略，
                                                           * 因为这种情况下是允许SQL语句作为注解打在接口上的，所以xml文件不是必须的，
                                                           * 而对于直接声明的xml mapper文件，如果找不到的话会抛出IOException异常而终止，这在使用注解模式的时候需要注意。
                                                           * 加载到对应的mapper.xml文件后，调用XMLMapperBuilder进行解析。
                                                           *
                                                           * 在创建XMLMapperBuilder时，我们发现用到了configuration.getSqlFragments()，
                                                           * 这就是我们在mapper文件中经常使用的可以被包含在其他语句中的SQL片段，但是我们并没有初始化过，
                                                           * 所以很有可能它是在解析过程中动态添加的，创建了XMLMapperBuilder之后，在调用其parse()接口进行具体xml的解析，
                                                           * 这和mybatis-config的逻辑基本上是一致的思路

                                                           其实之前已经加载过xml文件了，所以configuration类中其实已经有了这个namespace了，
                                                           */
                                                    --> loadXmlResource()
                                                        --> if !configuration.isResourceLoaded("namespace:" + type.getName())
                                                        --> String xmlResource = type.getName().replace('.', '/') + ".xml";
                                                        --> InputStream inputStream = type.getResourceAsStream("/" + xmlResource);
                                                        --> XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
                                                        --> xmlParser.parse();

                                                    --> configuration.addLoadedResource(resource);

                                                    --> assistant.setCurrentNamespace("interface com.liang.UserMapper");

                                                        //添加注解的情况
                                                    --> parseCache();
                                                        --> CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);
                                                        --> assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);

                                                        //添加注解的情况
                                                    --> parseCacheRef();
                                                        --> CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);
                                                        --> assistant.useCacheRef(namespace);

                                                    --> Method[] methods = type.getMethods();

                                                        //添加注解的情况
                                                        // 获取参数类型,如果有多个参数,这种情况下就返回org.apache.ibatis.binding.MapperMethod.ParamMap.class，
                                                        // ParamMap是一个继承于HashMap的类，否则返回实际类型
                                                    --> parseStatement("public abstract com.liang.User com.liang.UserMapper.getUserById(java.lang.String)");
                                                        --> Class<?> parameterTypeClass = getParameterType(method);
                                                            --> Class<?>[] parameterTypes = method.getParameterTypes(); // class java.lang.String

                                                            //获取方法的SqlSource对象,只有指定了@Select/@Insert/@Update/@Delete或者对应的Provider的方法才会被当作mapper,否则只是和mapper文件中对应语句的一个运行时占位符
                                                        --> SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver); // null 从注解上面解析出来的sql语句
                                                            --> assistant.addMappedStatement(mappedStatementId,
                                                                                                       sqlSource,
                                                                                                       statementType,
                                                                                                       sqlCommandType,
                                                                                                       fetchSize,
                                                                                                       timeout,
                                                                                                       // ParameterMapID
                                                                                                       null,
                                                                                                       parameterTypeClass,
                                                                                                       resultMapId,
                                                                                                       getReturnType(method),
                                                                                                       resultSetType,
                                                                                                       flushCache,
                                                                                                       useCache,
                                                                                                       false,
                                                                                                       keyGenerator,
                                                                                                       keyProperty,
                                                                                                       keyColumn,
                                                                                                       // DatabaseID
                                                                                                       null,
                                                                                                       languageDriver,
                                                                                                       // ResultSets
                                                                                                       options != null ? nullOrEmpty(options.resultSets()) : null);

                                                    --> parsePendingMethods()
                                                            //将所有configuration类中没有完成的方法都取出来，然后在执行一遍
                                                        --> Collection<MethodResolver> incompleteMethods = configuration.getIncompleteMethods();
                                                        --> iter.next().resolve();
                                                        --> iter.remove();


                                    --> parsePendingResultMaps();
                                            //将所有configuration类中没有完成的resultMap都取出来，然后在执行一遍
                                        --> Collection<ResultMapResolver> incompleteResultMaps = configuration.getIncompleteResultMaps();
                                        --> iter.next().resolve();
                                        --> iter.remove();

                                    --> parsePendingCacheRefs();
                                            //将所有configuration类中没有完成的cacheRefs都取出来，然后在执行一遍
                                        --> Collection<CacheRefResolver> incompleteCacheRefs = configuration.getIncompleteCacheRefs();
                                        --> iter.next().resolveCacheRef();
                                        --> iter.remove();

                                    --> parsePendingStatements();
                                        //将所有configuration类中没有完成的statement都取出来，然后在执行一遍
                                        --> Collection<XMLStatementBuilder> incompleteStatements = configuration.getIncompleteStatements();
                                        --> iter.next().parseStatementNode();
                                        --> iter.remove();

            --> return build(configuration)
                --> return new DefaultSqlSessionFactory(config);

        /**
         *
         * 主要有多种形式的重载，除了使用默认设置外，可以指定自动提交模式、特定的jdbc连接、事务隔离级别，
         * 以及指定的执行器类型。
         * 关于执行器类型，mybatis提供了三种执行器类型：SIMPLE, REUSE, BATCH。
         * 后面我们会详细分析每种类型的执行器的差别以及各自的适用场景。
         * 我们以最简单的无参方法切入
         * （按照一般的套路，如果定义了多个重载的方法或者构造器，内部实现一定是设置作者认为最合适的默认值，然后调用次多参数的方法，直到最后）
         */
    --> SqlSession sqlSession = sqlSessionFactory.openSession();
        --> DefaultSqlSessionFactory.openSession()
                // 使用默认的执行器类型(默认是SIMPLE)，默认隔离级别，非自动提交 委托给openSessionFromDataSource方法
            --> openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false)
                    /**
                       * mybatis的事务管理模式分为两种，自动提交和手工提交，
                       * DefaultSqlSessionFactory的openSession中重载中，
                       * 提供了一个参数用于控制是否自动提交事务，
                       * 该参数最终被传递给 java.sql.Connection.setAutoCommit()方法用于控制是否自动提交事务(默认情况下，连接是自动提交的)
                       */
                --> openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit)
                    --> final Environment environment = configuration.getEnvironment();
                    --> final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); // 获取事务管理器, 支持从数据源或者直接获取
                            // 如果没有配置environment或者environment的事务管理器为空,则使用受管的事务管理器
                            // 除非什么都没有配置,否则在mybatis-config里面,至少要配置一个environment，此时事务工厂不允许为空
                            // 对于jdbc类型的事务管理器,则返回JdbcTransactionFactory,其内部操作mybatis的JdbcTransaction实现(采用了Facade模式)，后者对jdbc连接操作
                        --> return environment.getTransactionFactory();

                        // 从数据源创建一个事务, 同样,数据源必须配置,
                        // mybatis内置了JNDI、POOLED、UNPOOLED三种类型的数据源,
                        // 其中POOLED对应的实现为org.apache.ibatis.datasource.pooled.PooledDataSource,
                        // 它是mybatis自带实现的一个同步、线程安全的数据库连接池 一般在生产中,我们会使用dbcp或者druid连接池
                    --> tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
                        --> return new JdbcTransaction(ds, level, autoCommit);
                            --> dataSource = ds;
                                level = desiredLevel;
                                autoCommit = desiredAutoCommit;

                        /**
                         *
                         * 什么是执行器？所有我们在应用层通过sqlSession执行的各类selectXXX和增删改操作在做了动态sql和参数相关的封装处理后，
                         * 都被委托给具体的执行器去执行，包括一、二级缓存的管理，事务的具体管理，
                         * Statement和具体JDBC层面优化的实现等等。所以执行器比较像是sqlSession下的各个策略工厂实现，
                         * 用户通过配置决定使用哪个策略工厂。
                         * 只不过执行器在一个mybatis配置下只有一个，这可能无法适应于所有的情况，
                         * 尤其是哪些微服务做得不是特别好的中小型公司，因为这些系统通常混搭了OLTP和ETL功能。
                         */
                    --> final Executor executor = configuration.newExecutor(tx, SIMPLE);
                        --> executor = new SimpleExecutor(this, transaction);
                            --> this.transaction = transaction;
                                this.deferredLoads = new ConcurrentLinkedQueue<>();
                                this.localCache = new PerpetualCache("LocalCache"); // mybatis的二级缓存 PerpetualCache实际上内部使用的是常规的Map
                                this.localOutputParameterCache = new PerpetualCache("LocalOutputParameterCache"); // 用于存储过程出参
                                this.closed = false;
                                this.configuration = configuration;
                                this.wrapper = this;

                            //缓存执行器不是真正功能上独立的执行器，而是非缓存执行器的装饰器模式。
                        --> executor = new CachingExecutor(executor);

                        --> executor = (Executor) interceptorChain.pluginAll(executor);
                            --> protected final InterceptorChain interceptorChain = new InterceptorChain();
                                --> private final List<Interceptor> interceptors = new ArrayList<>();
                            --> interceptor.plugin(executor)
                                --> Interceptor.plugin(executor)
                                    --> Plugin.wrap(executor, this)
                                        --> Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
                                            --> Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);
                                            --> Signature[] sigs = interceptsAnnotation.value();
                                            --> Set<Method> methods = signatureMap.computeIfAbsent(sig.type(), k -> new HashSet<>());
                                            --> Method method = sig.type().getMethod(sig.method(), sig.args());
                                            --> methods.add(method);
                                            --> return signatureMap;

                                        --> Class<?> type = executor.getClass();  //class org.apache.ibatis.executor.CachingExecutor
                                        --> Class<?>[] interfaces = getAllInterfaces(type, signatureMap); //["interface org.apache.ibatis.executor.Executor"]

                                            //生成executor的动态代理对象，每个Plugin都实现了InvocationHandler接口，相当于在executor外面包装了好几层
                                        --> return Proxy.newProxyInstance(
                                                      type.getClassLoader(),
                                                      interfaces,
                                                      new Plugin(executor, interceptor, signatureMap));

                        --> return executor

                    --> return new DefaultSqlSession(configuration, executor, autoCommit)
                        --> this.configuration = configuration;
                            this.executor = executor;
                            this.dirty = false;
                            this.autoCommit = autoCommit;


    --> List<User> list = sqlSession.selectList("com.liang.UserMapper.getUsers");
        --> DefaultSqlSession.selectList("com.liang.UserMapper.getUsers")
            --> DefaultSqlSession.selectList("com.liang.UserMapper.getUsers", parameter, rowBounds)

                --> MappedStatement ms = Configuration.getMappedStatement("com.liang.UserMapper.getUsers")
                    --> getMappedStatement("com.liang.UserMapper.getUsers", true)
                            //将所有未初始化的方法，缓存等在重亲初始化一遍
                        --> buildAllStatements()
                        --> return mappedStatements.get("com.liang.UserMapper.getUsers")

                --> parameter = wrapCollection(parameter)   // null

                --> return executor.query(ms, parameter, rowBounds, Executor.NO_RESULT_HANDLER);
                        //首先会被plugin拦截
                    --> Plugin.invoke

                    --> CachingExecutor.query(MappedStatement, parameterObject, RowBounds, ResultHandler)
                        --> BoundSql boundSql = ms.getBoundSql(parameterObject);

                            --> BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
                                --> StaticSqlSource.getBoundSql(parameterObject)
                                    --> return new BoundSql(configuration, sql, parameterMappings, parameterObject);
                            --> List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();
                            --> boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);

                            //设置缓存
                            /**
                               * 在mybatis的缓存实现中，
                               * 缓存键CacheKey的格式为：cacheKey=ID + offset + limit + sql + parameterValues + environmentId
                               *
                               * 对于一级缓存，commit/rollback都会清空一级缓存。
                               * 对于二级缓存，DML操作或者显示设置语句层面的flushCache属性都会使得二级缓存失效。
                               * 　　在二级缓存容器的具体回收策略实现上，有下列几种：
                               *
                               * LRU – 最近最少使用的：移除最长时间不被使用的对象，也是默认的选项，其实现类是org.apache.ibatis.cache.decorators.LruCache。
                               * FIFO – 先进先出：按对象进入缓存的顺序来移除它们，其实现类是org.apache.ibatis.cache.decorators.FifoCache。
                               * SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象，其实现类是org.apache.ibatis.cache.decorators.SoftCache。
                               * WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象，其实现类是org.apache.ibatis.cache.decorators.WeakCache。

                                 在缓存的设计上，Mybatis的所有Cache算法都是基于装饰器/Composite模式对PerpetualCache扩展增加功能。

                               　 对于模块化微服务系统来说，应该来说mybatis的一二级缓存对业务数据都不适合，
                                  尤其是对于OLTP系统来说，CRM/BI这些不算，如果要求数据非常精确的话，也不是特别合适。
                                  对这些要求数据准确的系统来说，尽可能只使用mybatis的ORM特性比较靠谱。
                                  但是有一部分数据如果前期没有很少的设计缓存的话，是很有价值的，
                                  比如说对于一些配置类数据比如数据字典、系统参数、业务配置项等很少变化的数据。
                               */
                        --> CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
                            --> CachingExecutor.createCacheKey(ms, parameterObject, rowBounds, boundSql)
                                --> simpleExecutor.createCacheKey(ms, parameterObject, rowBounds, boundSql)
                                        // 根据映射语句id,分页信息,jdbc规范化的预编译sql,所有映射参数的值以及环境id的值,计算出缓存Key
                                    --> CacheKey cacheKey = new CacheKey();
                                        cacheKey.update(ms.getId());
                                        cacheKey.update(rowBounds.getOffset());
                                        cacheKey.update(rowBounds.getLimit());
                                        cacheKey.update(boundSql.getSql());
                                        cacheKey.update(configuration.getEnvironment().getId());

                        --> return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                            --> simpleExecutor.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql)
                                    // 如果查询不需要应用结果处理器,则先从缓存获取,这样可以避免数据库查询。我们后面会分析到localCache是什么时候被设置进去的
                                    // 如果在一级缓存中就直接获取
                                --> list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;

                                    //不管是因为需要应用结果处理器还是缓存中没有,都从数据库中查询
                                --> list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
                                    --> localCache.putObject("1322964187:1136138037:com.liang.UserMapper.getUsers:0:2147483647:select id,username,password from user:development", EXECUTION_PLACEHOLDER);

                                        // doQuery是个抽象方法,每个具体的执行器都要自己去实现,我们先看SIMPLE的
                                    --> simpleExecutor.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
                                            // 根据上下文参数和具体的执行器new一个StatementHandler,
                                            // 其中包含了所有必要的信息,比如结果处理器、参数处理器、执行器等等,
                                            // 主要有三种类型的语句处理器UNPREPARE、PREPARE、CALLABLE。
                                            // 默认是PREPARE类型，通过mapper语句上的statementType属性进行设置,一般除了存储过程外不应该设置
                                        --> StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
                                            --> StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
                                                --> statementHandler = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                                                    --> BaseStatementHandler(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql)
                                                        --> this.configuration = mappedStatement.getConfiguration();
                                                            this.executor = executor;
                                                            this.mappedStatement = mappedStatement;
                                                            this.rowBounds = rowBounds;

                                                            this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();
                                                            this.objectFactory = configuration.getObjectFactory();
                                                            this.boundSql = boundSql;

                                                            this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);
                                                                --> ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
                                                                    --> XMLLanguageDriver.createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)
                                                                        --> return new DefaultParameterHandler(mappedStatement, parameterObject, boundSql);
                                                                            --> this.mappedStatement = mappedStatement;
                                                                                this.configuration = mappedStatement.getConfiguration();
                                                                                this.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();
                                                                                this.parameterObject = parameterObject;
                                                                                this.boundSql = boundSql;

                                                                    //为parameterHandler设置拦截器
                                                                --> parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
                                                                --> return parameterHandler

                                                            this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);
                                                                --> ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
                                                                    --> this.executor = executor;
                                                                        this.configuration = mappedStatement.getConfiguration();
                                                                        this.mappedStatement = mappedStatement;
                                                                        this.rowBounds = rowBounds;
                                                                        this.parameterHandler = parameterHandler;
                                                                        this.boundSql = boundSql;
                                                                        this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();
                                                                        this.objectFactory = configuration.getObjectFactory();
                                                                        this.reflectorFactory = configuration.getReflectorFactory();
                                                                        this.resultHandler = resultHandler;

                                                                    //为resultSetHandler设置拦截器
                                                                --> resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
                                                                --> return resultSetHandler;

                                                //为statementHandler设置拦截器
                                            --> statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler)
                                            --> return statementHandler

                                        --> stmt = prepareStatement(handler, ms.getStatementLog());
                                            --> SimpleExecutor.prepareStatement(StatementHandler handler, Log statementLog)
                                                    // 获取JDBC连接
                                                --> Connection connection = getConnection(statementLog);
                                                    --> Connection connection = transaction.getConnection();
                                                        --> JdbcTransaction.getConnection()
                                                            --> openConnection();
                                                                --> connection = dataSource.getConnection();
                                                                    --> PooledDataSource.getConnection()
                                                                        --> pooledConnection = popConnection("root", "root")

                                                                            --> connection = dataSource.getConnection()
                                                                                --> UnpooledDataSource.getConnection()
                                                                                    --> doGetConnection(username, password)
                                                                                        --> doGetConnection(props) //props 里面存着username和password
                                                                                            --> initializeDriver();
                                                                                                    --> if(!registeredDrivers.containsKey(driver))
                                                                                                    --> driverType = Class.forName(driver, true, driverClassLoader);
                                                                                                    --> Driver driverInstance = (Driver)driverType.newInstance();
                                                                                                    --> registeredDrivers.put(driver, driverInstance);

                                                                                            --> Connection connection = DriverManager.getConnection(url, properties);
                                                                                                    --> com.mysql.jdbc.NonRegisteringDriver.connect(url, properties)
                                                                                                    --> Connection newConn = com.mysql.jdbc.ConnectionImpl.getInstance(host(props), port(props), props, database(props), url);
                                                                                                        --> com.mysql.jdbc.ConnectionImpl.getInstance
                                                                                                            --> JDBC_4_CONNECTION_CTOR = Class.forName("com.mysql.jdbc.JDBC4Connection").getConstructor(new Class[] { String.class, Integer.TYPE, Properties.class, String.class, String.class })
                                                                                                            --> return (Connection) Util.handleNewInstance(JDBC_4_CONNECTION_CTOR,new Object[] { hostToConnectTo, Integer.valueOf(portToConnectTo), info, databaseToConnectTo, url }
                                                                                                                    //在这个方法里面进行了一些连接的基本配置，用户名密码，ip端口之类的
                                                                                                                --> ctor.newInstance(args)
                                                                                                                    --> initializeDriverProperties(info)
                                                                                                                        --> initializeProperties(info);
                                                                                                                        --> this.usePlatformCharsetConverters = getUseJvmCharsetConverters();
                                                                                                                        .
                                                                                                                        .
                                                                                                                        .
                                                                                                                    --> this.dbmd = getMetaData(false, false);
                                                                                                                        --> return com.mysql.jdbc.DatabaseMetaData.getInstance(getMultiHostSafeProxy(), this.database, checkForInfoSchema);

                                                                                                                            --> JDBC_4_DBMD_SHOW_CTOR = Class.forName("com.mysql.jdbc.JDBC4DatabaseMetaData").getConstructor(new Class[] { com.mysql.jdbc.MySQLConnection.class, String.class });

                                                                                                                            --> return (DatabaseMetaData) Util.handleNewInstance(JDBC_4_DBMD_SHOW_CTOR, new Object[] { connToSet, databaseToSet }, connToSet.getExceptionInterceptor());

                                                                                                                    --> initializeSafeStatementInterceptors();

                                                                                                                    --> createNewIO(false);
                                                                                                                        --> Properties mergedProps = exposeAsProperties(this.props);
                                                                                                                        --> connectOneTryOnly(isForReconnect, mergedProps)
                                                                                                                            --> coreConnect(mergedProps)
                                                                                                                                --> int newPort = 3306;
                                                                                                                                    String newHost = "10.4.249.94";
                                                                                                                                    this.port = newPort;
                                                                                                                                    this.host = newHost;
                                                                                                                                    this.sessionMaxRows = -1;
                                                                                                                                    this.serverVariables = new HashMap<String, String>();
                                                                                                                                    this.serverVariables.put("character_set_server", "utf8");
                                                                                                                                    this.io = new MysqlIO(newHost, newPort, mergedProps, getSocketFactoryClassName(), getProxy(), getSocketTimeout(),this.largeRowSizeThreshold.getValueAsInt());
                                                                                                                                        --> this.connection = conn
                                                                                                                                            this.traceProtocol = this.connection.getTraceProtocol()
                                                                                                                                            this.useAutoSlowLog = this.connection.getAutoSlowLog()
                                                                                                                                            this.useBufferRowSizeThreshold = useBufferRowSizeThreshold;
                                                                                                                                            this.useDirectRowUnpack = this.connection.getUseDirectRowUnpack();

                                                                                                                                            this.logSlowQueries = this.connection.getLogSlowQueries();

                                                                                                                                            this.reusablePacket = new Buffer(INITIAL_PACKET_SIZE);
                                                                                                                                            this.sendPacket = new Buffer(INITIAL_PACKET_SIZE);

                                                                                                                                            this.port = port;
                                                                                                                                            this.host = host;

                                                                                                                                            this.socketFactoryClassName = socketFactoryClassName; //com.mysql.jdbc.StandardSocketFactory
                                                                                                                                            this.socketFactory = createSocketFactory();
                                                                                                                                                --> return (SocketFactory) (Class.forName("com.mysql.jdbc.StandardSocketFactory").newInstance());
                                                                                                                                            this.exceptionInterceptor = this.connection.getExceptionInterceptor();
                                                                                                                                            this.mysqlConnection = this.socketFactory.connect(this.host, this.port, props);
                                                                                                                                                --> com.mysql.jdbc.StandardSocketFactory.connect(host, port, props)

                                                                                                                                                    --> this.rawSocket = createSocket(props);
                                                                                                                                                        --> return new Socket();

                                                                                                                                                    --> configureSocket(rawSocket, props);
                                                                                                                                                        --> rawSocket.setTcpNoDelay(Boolean.valueOf(props.getProperty(TCP_NO_DELAY_PROPERTY_NAME, TCP_NO_DELAY_DEFAULT_VALUE)).booleanValue());
                                                                                                                                                        --> rawSocket.setKeepAlive(Boolean.valueOf(keepAlive).booleanValue());
                                                                                                                                                        --> rawSocket.setReceiveBufferSize(receiveBufferSize);
                                                                                                                                                        --> rawSocket.setSendBufferSize(sendBufferSize);
                                                                                                                                                        --> rawSocket.setTrafficClass(trafficClass);

                                                                                                                                                    --> InetSocketAddress sockAddr = new InetSocketAddress("10.4.249.94", this.port);

                                                                                                                                                    --> this.rawSocket.connect(sockAddr, getRealTimeout(connectTimeout));
                                                                                                                                                        --> java.net.Socket.connect(java.net.SocketAddress, int)
                                                                                                                                                            --> SecurityManager security = System.getSecurityManager();
                                                                                                                                                            --> security.checkConnect(addr.getHostAddress(), port);
                                                                                                                                                            --> java.net.SocksSocketImpl.connect(SocketAddress endpoint, int timeout)
                                                                                                                                                                --> uri = new URI("socket://" + ParseUtil.encodePath(host) + ":"+ epoint.getPort());
                                                                                                                                                                --> java.net.AbstractPlainSocketImpl.connect(java.net.SocketAddress, int timeout)
                                                                                                                                                                    --> connectToAddress(this.address, port, timeout);
                                                                                                                                                                        --> doConnect(address, port, timeout);
                                                                                                                                                                            --> NetHooks.beforeTcpConnect(fd, address, port);
                                                                                                                                                                            --> socketConnect(address, port, timeout);
                                                                                                                                                                                --> native void socketConnect(InetAddress address, int port, int timeout) throws IOException;
                                                                                                                                                    --> return this.rawSocket

                                                                                                                                            this.mysqlConnection = this.socketFactory.beforeHandshake();
                                                                                                                                            this.mysqlInput = new ReadAheadInputStream(this.mysqlConnection.getInputStream(), 16384, this.connection.getTraceProtocol(),this.connection.getLog());
                                                                                                                                            this.mysqlOutput = new BufferedOutputStream(this.mysqlConnection.getOutputStream(), 16384);

                                                                                                                                    //这里开始就有认证了
                                                                                                                                    this.io.doHandshake(this.user, this.password, this.database);
                                                                                                                                        --> Buffer buf = readPacket();
                                                                                                                                        --> this.serverVersion = buf.readString("ASCII", getExceptionInterceptor()); // 5.7.26
                                                                                                                                        --> proceedHandshakeWithPluggableAuthentication(user, password, database, buf);
                                                                                                                                            --> loadAuthenticationPlugins();
                                                                                                                                                --> AuthenticationPlugin plugin = new MysqlOldPasswordPlugin();
                                                                                                                                                    plugin.init(this.connection, this.connection.getProperties());

                                                                                                                                                    plugin = new MysqlNativePasswordPlugin();
                                                                                                                                                    plugin.init(this.connection, this.connection.getProperties());

                                                                                                                                                    plugin = new MysqlClearPasswordPlugin();
                                                                                                                                                    plugin.init(this.connection, this.connection.getProperties());

                                                                                                                                                    plugin = new Sha256PasswordPlugin();
                                                                                                                                                    plugin.init(this.connection, this.connection.getProperties());

                                                                                                                                                    plugin = new CachingSha2PasswordPlugin();
                                                                                                                                                    plugin.init(this.connection, this.connection.getProperties());
                                                                                                                                            --> negotiateSSLConnection(user, password, database, packLength);
                                                                                                                                                --> ExportControlled.transformSocketToSSLSocket(MysqlIO mysqlIO);
                                                                                                                                                    --> SocketFactory sslFact = new StandardSSLSocketFactory(getSSLSocketFactoryDefaultOrConfigured(mysqlIO), mysqlIO.socketFactory, mysqlIO.mysqlConnection);
                                                                                                                                                    --> mysqlIO.mysqlConnection = sslFact.connect(mysqlIO.host, mysqlIO.port, null);
                                                                                                                                                    --> ((SSLSocket) mysqlIO.mysqlConnection).startHandshake();
                                                                                                                                                    --> mysqlIO.mysqlInput = mysqlIO.mysqlConnection.getInputStream();
                                                                                                                                                    --> mysqlIO.mysqlOutput = new BufferedOutputStream(mysqlIO.mysqlConnection.getOutputStream(), 16384);
                                                                                                                                                    --> mysqlIO.socketFactory = sslFact;

                                                                                                                                            --> plugin = getAuthenticationPlugin("mysql_native_password")
                                                                                                                                            --> plugin.setAuthenticationParameters(user, skipPassword ? null : password);
                                                                                                                                            --> done = plugin.nextAuthenticationStep(fromServer, toServer); // true
                                                                                                                                            --> send(last_sent, last_sent.getPosition());
                                                                                                                                            --> this.mysqlConnection = this.socketFactory.afterHandshake();


                                                                                                                            --> initializePropsFromServer();
                                                                                                                                --> setSessionVariables(); // 好像针对老版本的

                                                                                                                                --> loadServerVariables();
                                                                                                                                    --> stmt = getMetadataSafeStatement();
                                                                                                                                        --> com.mysql.jdbc.ConnectionImpl.getMetadataSafeStatement(int maxRows)
                                                                                                                                            --> java.sql.Statement stmt = createStatement();
                                                                                                                                                --> StatementImpl stmt = new StatementImpl(getMultiHostSafeProxy(), this.database);
                                                                                                                                                    stmt.setResultSetType(resultSetType);
                                                                                                                                                    stmt.setResultSetConcurrency(resultSetConcurrency);

                                                                                                                                                stmt.setMaxRows(maxRows == -1 ? 0 : maxRows);
                                                                                                                                                stmt.setEscapeProcessing(false);
                                                                                                                                                return stmt;

                                                                                                                                    --> StringBuilder queryBuf = new StringBuilder(versionComment).append("SELECT");
                                                                                                                                        queryBuf.append("  @@session.auto_increment_increment AS auto_increment_increment");
                                                                                                                                        queryBuf.append(", @@character_set_client AS character_set_client");
                                                                                                                                        queryBuf.append(", @@character_set_connection AS character_set_connection");
                                                                                                                                        queryBuf.append(", @@character_set_results AS character_set_results");
                                                                                                                                        queryBuf.append(", @@character_set_server AS character_set_server");
                                                                                                                                        queryBuf.append(", @@collation_server AS collation_server");
                                                                                                                                        queryBuf.append(", @@collation_connection AS collation_connection");
                                                                                                                                        queryBuf.append(", @@init_connect AS init_connect");
                                                                                                                                        queryBuf.append(", @@interactive_timeout AS interactive_timeout");
                                                                                                                                        if (!versionMeetsMinimum(5, 5, 0)) {
                                                                                                                                            queryBuf.append(", @@language AS language");
                                                                                                                                        }
                                                                                                                                        queryBuf.append(", @@license AS license");
                                                                                                                                        queryBuf.append(", @@lower_case_table_names AS lower_case_table_names");
                                                                                                                                        queryBuf.append(", @@max_allowed_packet AS max_allowed_packet");
                                                                                                                                        queryBuf.append(", @@net_buffer_length AS net_buffer_length");
                                                                                                                                        queryBuf.append(", @@net_write_timeout AS net_write_timeout");
                                                                                                                                        if (!versionMeetsMinimum(8, 0, 3)) {
                                                                                                                                            queryBuf.append(", @@query_cache_size AS query_cache_size");
                                                                                                                                            queryBuf.append(", @@query_cache_type AS query_cache_type");
                                                                                                                                        }
                                                                                                                                        queryBuf.append(", @@sql_mode AS sql_mode");
                                                                                                                                        queryBuf.append(", @@system_time_zone AS system_time_zone");
                                                                                                                                        queryBuf.append(", @@time_zone AS time_zone");
                                                                                                                                        if (versionMeetsMinimum(8, 0, 3) || (versionMeetsMinimum(5, 7, 20) && !versionMeetsMinimum(8, 0, 0))) {
                                                                                                                                            queryBuf.append(", @@transaction_isolation AS transaction_isolation");
                                                                                                                                        } else {
                                                                                                                                            queryBuf.append(", @@tx_isolation AS transaction_isolation");
                                                                                                                                        }
                                                                                                                                        queryBuf.append(", @@wait_timeout AS wait_timeout");

                                                                                                                                        results = stmt.executeQuery(queryBuf.toString());

                                                                                                                                        ResultSetMetaData rsmd = results.getMetaData();

                                                                                                                                        this.serverVariables.put(rsmd.getColumnLabel(i), results.getString(i));

                                                                                                                                --> buildCollationMapping();

                                                                                                                                --> configureTimezone();

                                                                                                                                --> int serverMaxAllowedPacket = getServerVariableAsInt("max_allowed_packet", -1);

                                                                                                                                --> setMaxAllowedPacket(serverMaxAllowedPacket);

                                                                                                                                --> checkTransactionIsolationLevel();
                                                                                                                                    --> String s = this.serverVariables.get("transaction_isolation") //REPEATABLE-READ
                                                                                                                                    --> Integer intTI = mapTransIsolationNameToValue.get(s)
                                                                                                                                    --> this.isolationLevel = intTI.intValue(); //4

                                                                                                                                    //Sets up client character set for MySQL-4.1 and newer if the user This
                                                                                                                                    //must be done before any further communication with the server!
                                                                                                                                --> configureClientCharacterSet(false);

                                                                                                                                --> handleAutoCommitDefaults();
                                                                                                                                    --> resetAutoCommitDefault = true;
                                                                                                                                    --> setAutoCommit(true)

                                                                                                                                --> defaultMetadataCharset = "UTF-8";

                                                                                                                                --> setupServerForTruncationChecks();


                                                                                                                    --> unSafeStatementInterceptors();

                                                                                                    --> return newConn

                                                                                                //配置一下连接，没什么业务逻辑
                                                                                            --> configureConnection(connection);

                                                                                            --> return connection;

                                                                            --> conn = new PooledConnection(connection, this);
                                                                                --> this.hashCode = connection.hashCode();
                                                                                    this.realConnection = connection;
                                                                                    this.dataSource = dataSource;
                                                                                    this.createdTimestamp = System.currentTimeMillis();
                                                                                    this.lastUsedTimestamp = System.currentTimeMillis();
                                                                                    this.valid = true;
                                                                                    this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);

                                                                            --> state.activeConnections.add(conn);
                                                                                ~ protected final List<PooledConnection> idleConnections = new ArrayList<>();
                                                                                ~ protected final List<PooledConnection> activeConnections = new ArrayList<>();

                                                                            --> return conn;


                                                                        --> return pooledConnection.getProxyConnection();

                                                                --> connection.setTransactionIsolation(level.getLevel());
                                                                --> setDesiredAutoCommit(autoCommit);

                                                    --> return ConnectionLogger.newInstance(connection, statementLog, queryStack); // 动态记日志
                                                        --> InvocationHandler handler = new ConnectionLogger(conn, statementLog, queryStack);
                                                            ClassLoader cl = Connection.class.getClassLoader();
                                                            return (Connection) Proxy.newProxyInstance(cl, new Class[]{Connection.class}, handler);


                                                    // 调用语句处理器的prepare方法
                                                --> stmt = handler.prepare(connection, transaction.getTimeout());
                                                    --> RoutingStatementHandler.prepare(connection, transactionTimeout)
                                                        --> preparedStatementHandler.prepare(connection, transactionTimeout)
                                                                // 首先实例化语句，因为PREPARE和非PREPARE不同,所以留给具体子类实现
                                                                // 不同类型语句的初始化过程不同,比如Statement语句直接调用JDBC java.sql.Connection.createStatement，
                                                                // 而PrepareStatement则是调用java.sql.Connection.prepareStatement
                                                            --> statement = instantiateStatement(connection);
                                                                --> String sql = boundSql.getSql();
                                                                --> return connection.prepareStatement(sql);
                                                                    --> PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);
                                                                        --> PooledConnection.invoke
                                                                        --> return method.invoke(realConnection, args);
                                                                            --> com.mysql.jdbc.ConnectionImpl.prepareStatement(java.lang.String)
                                                                                --> return prepareStatement(sql, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);
                                                                                    --> String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql; // select id,username,password from user

                                                                                    --> pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, false);
                                                                                        --> pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database);

                                                                                            --> private static final Constructor<?> JDBC_4_PSTMT_3_ARG_CTOR = Class.forName("com.mysql.jdbc.JDBC42PreparedStatement").getConstructor(new Class[] { MySQLConnection.class, String.class, String.class });

                                                                                            --> return (PreparedStatement) Util.handleNewInstance(JDBC_4_PSTMT_3_ARG_CTOR, new Object[] { conn, sql, catalog }, conn.getExceptionInterceptor());
                                                                                                --> return ctor.newInstance(args);
                                                                                                    --> PreparedStatement(MySQLConnection conn, String sql, String catalog)
                                                                                                        --> this.originalSql = sql;
                                                                                                            this.staticSqlStrings = this.parseInfo.staticSql;
                                                                                                            this.isLoadDataQuery = this.parseInfo.foundLoadData;
                                                                                                            this.firstCharOfStmt = this.parseInfo.firstStmtChar;

                                                                                                            this.parameterCount = this.staticSqlStrings.length - 1;

                                                                                                            this.parameterValues = new byte[this.parameterCount][];
                                                                                                            this.parameterStreams = new InputStream[this.parameterCount];
                                                                                                            this.isStream = new boolean[this.parameterCount];
                                                                                                            this.streamLengths = new int[this.parameterCount];
                                                                                                            this.isNull = new boolean[this.parameterCount];
                                                                                                            this.parameterTypes = new int[this.parameterCount];

                                                                                        --> pStmt.setResultSetType(resultSetType);
                                                                                        --> pStmt.setResultSetConcurrency(resultSetConcurrency);
                                                                                        --> return pStmt
                                                                                    --> return pStmt

                                                                    --> stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);
                                                                        --> InvocationHandler handler = new PreparedStatementLogger(stmt, statementLog, queryStack);
                                                                        --> return (PreparedStatement) Proxy.newProxyInstance(cl, new Class[]{PreparedStatement.class, CallableStatement.class}, handler);

                                                                    --> return stmt

                                                                // 设置JDBC语句超时时间,注：数据库服务器端也可以设置语句超时时间。mysql通过参数max_statement_time设置,oracle截止12.2c不支持
                                                            --> setStatementTimeout(statement, transactionTimeout);

                                                                // 设置fetch大小
                                                                // fetchSize设置每次从服务器端提取的行数,默认不同数据库实现不同,mysql一次性提取全部,oracle默认10。
                                                                // 正确设置fetchSize可以避免OOM并且对性能有一定的影响,尤其是在网络延时较大的情况下
                                                            --> setFetchSize(statement);

                                                            --> return statement;

                                                    // 设置参数
                                                --> handler.parameterize(stmt);
                                                    --> RoutingStatementHandler.parameterize(stmt)
                                                        --> preparedStatementHandler.parameterize(stmt)

                                                --> return stmt;

                                        --> return handler.query(stmt, resultHandler)
                                            --> preparedStatementHandler.query(statement, resultHandler)
                                                --> PreparedStatement ps = (PreparedStatement) statement;
                                                --> ps.execute();
                                                    --> PreparedStatement.execute()
                                                        --> MySQLConnection locallyScopedConn = this.connection;
                                                        --> resetCancelledState();
                                                        --> setupStreamingTimeout(locallyScopedConn)
                                                            //里面填充了用户名密码等信息
                                                        --> Buffer sendPacket = fillSendPacket();
                                                        --> rs = executeInternal(this.maxRows, sendPacket, createStreamingResultSet(), (this.firstCharOfStmt == 'S'), metadataFromCache, false);
                                                            --> com.mysql.jdbc.PreparedStatement.executeInternal()
                                                                --> statementBegins()
                                                                    --> MySQLConnection physicalConn = this.connection.getMultiHostSafeProxy().getActiveMySQLConnection();
                                                                    --> this.physicalConnection = new WeakReference<MySQLConnection>(physicalConn);
                                                                --> rs = locallyScopedConnection.execSQL(this, null, maxRowsToRetrieve, sendPacket, this.resultSetType, this.resultSetConcurrency,createStreamingResultSet, this.currentCatalog, metadataFromCache, isBatch);
                                                                    --> return this.io.sqlQueryDirect(callingStatement, null, null, packet, maxRows, resultSetType, resultSetConcurrency, streamResults, catalog,cachedMetadata);
                                                                        --> Buffer resultPacket = sendCommand(MysqlDefs.QUERY, null, queryPacket, false, null, 0);
                                                                            --> checkForOutstandingStreamingData();
                                                                            --> clearInputStream();
                                                                            --> send(queryPacket, queryPacket.getPosition()); // packet passed by PreparedStatement
                                                                                --> Buffer packetToSend = packet;
                                                                                --> this.mysqlOutput.write(packetToSend.getByteBuffer(), 0, packetLen);
                                                                                --> this.mysqlOutput.flush();

                                                                            --> Buffer returnPacket = checkErrorPacket(3);
                                                                                --> resultPacket = reuseAndReadPacket(this.reusablePacket);

                                                                                --> checkErrorPacket(resultPacket);

                                                                                --> return resultPacket;

                                                                            --> return returnPacket;

                                                                        --> ResultSetInternalMethods rs = readAllResults(callingStatement, maxRows, resultSetType, resultSetConcurrency, streamResults, catalog, resultPacket,false, -1L, cachedMetadata);
                                                                            --> ResultSetImpl topLevelResultSet = readResultsForQueryOrUpdate(callingStatement, maxRows, resultSetType, resultSetConcurrency, streamResults, catalog, resultPacket, isBinaryEncoded, preSentColumnCount, metadataFromCache);
                                                                                --> com.mysql.jdbc.ResultSetImpl results = getResultSet(callingStatement, columnCount, maxRows, resultSetType, resultSetConcurrency, streamResults, catalog, isBinaryEncoded, metadataFromCache);
                                                                                        //计算总共有几列
                                                                                    --> Field[] fields = new Field[(int) columnCount];
                                                                                    --> Buffer fieldPacket = readPacket()
                                                                                    --> fields[i] = unpackField(fieldPacket, false)
                                                                                        //返回的rowData中包含查询出来的数据
                                                                                    --> RowData rowData = readSingleRowSet(columnCount, maxRows, resultSetConcurrency, isBinaryEncoded, (metadataFromCache == null) ? fields : metadataFromCache);
                                                                                        --> ArrayList<ResultSetRow> rows = new ArrayList<ResultSetRow>();
                                                                                        --> ResultSetRow row = nextRow(fields, (int) columnCount, isBinaryEncoded, resultSetConcurrency, false, useBufferRowExplicit, false, null);
                                                                                            --> return nextRowFast(fields, columnCount, isBinaryEncoded, resultSetConcurrency, useBufferRowIfPossible, useBufferRowExplicit, canReuseRowPacketForBufferRow);
                                                                                                --> byte[][] rowData = new byte[columnCount][]
                                                                                                --> return new ByteArrayRow(rowData, getExceptionInterceptor());
                                                                                                    --> this.exceptionInterceptor = exceptionInterceptor;
                                                                                                    --> this.internalRowData = internalRowData;

                                                                                            //将查询出来的数据一行一行加到list中
                                                                                        --> rows.add(row);
                                                                                        --> rowData = new RowDataStatic(rows);
                                                                                        --> return rowData;

                                                                                    --> ResultSetImpl rs = buildResultSetWithRows(callingStatement, catalog, (metadataFromCache == null) ? fields : metadataFromCache, rowData, resultSetType, resultSetConcurrency, isBinaryEncoded);
                                                                                        --> rs = com.mysql.jdbc.ResultSetImpl.getInstance(catalog, fields, rows, this.connection, callingStatement, false);
                                                                                            --> private static final Constructor<?> JDBC_4_RS_5_ARG_CTOR = JDBC_4_RS_5_ARG_CTOR = Class.forName("com.mysql.jdbc.JDBC42ResultSet") .getConstructor(new Class[] { String.class, Field[].class, RowData.class, MySQLConnection.class, com.mysql.jdbc.StatementImpl.class });
                                                                                            --> return (ResultSetImpl) Util.handleNewInstance(JDBC_4_RS_5_ARG_CTOR, new Object[] { catalog, fields, tuples, conn, creatorStmt }, conn.getExceptionInterceptor());
                                                                                                --> this.connection = conn;
                                                                                                    this.retainOwningStatement = false;
                                                                                                    if (this.connection != null) {
                                                                                                        this.exceptionInterceptor = this.connection.getExceptionInterceptor();
                                                                                                        this.useStrictFloatingPoint = this.connection.getStrictFloatingPoint();
                                                                                                        this.connectionId = this.connection.getId();
                                                                                                        this.useFastDateParsing = this.connection.getUseFastDateParsing();
                                                                                                        this.profileSql = this.connection.getProfileSql();
                                                                                                        this.retainOwningStatement = this.connection.getRetainStatementAfterResultSetClose();
                                                                                                        this.jdbcCompliantTruncationForReads = this.connection.getJdbcCompliantTruncationForReads();
                                                                                                        this.useFastIntParsing = this.connection.getUseFastIntParsing();
                                                                                                        this.serverTimeZoneTz = this.connection.getServerTimezoneTZ();
                                                                                                        this.padCharsWithSpace = this.connection.getPadCharsWithSpace();
                                                                                                    }
                                                                                                    .
                                                                                                    .
                                                                                                    initializeWithMetadata();
                                                                                                        --> Set<String> tableNamesSet = new HashSet<String>();
                                                                                                        --> Field f = this.fields[i];
                                                                                                        --> String tableName = f.getOriginalTableName();
                                                                                                        --> tableNamesSet.add(tableName);
                                                                                                        --> this.connection.reportNumberOfTablesAccessed(tableNamesSet.size());
                                                                                                    setRowPositionValidity();

                                                                                        --> rs.setResultSetType(resultSetType);
                                                                                        --> rs.setResultSetConcurrency(resultSetConcurrency);

                                                                                    --> return rs;

                                                                                --> return results

                                                                            --> return topLevelResultSet;

                                                                        --> return rs
                                                                --> return rs
                                                        --> this.lastInsertId = rs.getUpdateID();

                                                        --> this.results = rs

                                                --> return resultSetHandler.handleResultSets(ps);
                                                    --> final List<Object> multipleResults = new ArrayList<>();

                                                        // 返回jdbc ResultSet的包装形式,主要是将java.sql.ResultSetMetaData做了Facade模式,便于使用
                                                    --> ResultSetWrapper rsw = getFirstResultSet(stmt);
                                                        --> ResultSet rs = stmt.getResultSet();
                                                        --> return new ResultSetWrapper(rs, configuration)
                                                            --> this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();
                                                            --> this.resultSet = rs;
                                                            --> final int columnCount = metaData.getColumnCount();
                                                            --> columnNames.add(configuration.isUseColumnLabel() ? metaData.getColumnLabel(i) : metaData.getColumnName(i)); // [id,username,password]
                                                            --> jdbcTypes.add(JdbcType.forCode(metaData.getColumnType(i))); // [VARCHAR,VARCHAR,VARCHAR]
                                                            --> classNames.add(metaData.getColumnClassName(i)); // [java.lang.String,java.lang.String,java.lang.String]

                                                        // 绝大部分情况下一个查询只有一个ResultMap, 除非多结果集查询
                                                        // mappedStatement 绑定了namespace，
                                                    --> List<ResultMap> resultMaps = mappedStatement.getResultMaps(); //com.liang.UserMapper.baseResult 对象

                                                    --> validateResultMapsCount(rsw, resultMapCount);

                                                    --> ResultMap resultMap = resultMaps.get(resultSetCount);

                                                        // 根据resultMap的定义将resultset打包到应用端的multipleResults中
                                                        // 因为调用handleResultSet的只有handleResultSets，
                                                        // 按说其中第一个调用永远不会出现parentMapping==null的情况，
                                                        // 只有第二个调用才会出现这种情况，而且应该是连续的，
                                                        // 因为第二个调用就是为了处理嵌套resultMap。
                                                        // 所以在handleRowValues处理resultMap的时候，一定是主的先处理，嵌套的后处理，
                                                    --> handleResultSet(rsw, resultMap, multipleResults, null);
                                                        --> DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);

                                                            // 处理主记录，resultHander不为空,rowBounds不使用默认值,parentMapping传递null
                                                        --> handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
                                                            --> handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);
                                                                --> DefaultResultContext<Object> resultContext = new DefaultResultContext<>();
                                                                --> ResultSet resultSet = rsw.getResultSet();

                                                                    // 解析鉴别器，得到嵌套的最深的鉴别器对应的ResultMap，如果没有鉴别器，就返回最顶层的ResultMap
                                                                --> ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);

                                                                    // 这个时候resultMap是非常干净的,没有嵌套任何其他东西了，但是这也是最关键的地方，将ResultSet记录转换为业务层配置的对象类型或者Map类型
                                                                --> Object rowValue = getRowValue(rsw, discriminatedResultMap, null);
                                                                        /**
                                                                         * // 有三个createResultObject重载，这三个重载完成的功能从最里面到最外面分别是：
                                                                         * 1、使用构造器创建目标对象类型;
                                                                         *    先判断是否有目标对象类型的处理器，有的话，直接调用类型处理器(这里为什么一定是原生类型)创建目标对象
                                                                         *    如果没有，判断是否有构造器，有的话，使用指定的构造器创建目标对象（构造器里面如果嵌套了查询或者ResultMap，则进行处理）
                                                                         *    如果结果类型是接口或者具有默认构造器，则使用ObjectFactory创建默认目标对象
                                                                         *    最后判断是否可以应用自动映射，默认是对非嵌套查询，只要没有明确设置AutoMappingBehavior.NONE就可以，对于嵌套查询，AutoMappingBehavior.FULL就可以。自动映射的逻辑是先找目标对象上具有@AutomapConstructor注解的构造器，然后根据ResultSet返回的字段清单找匹配的构造器，如果找不到，就报错
                                                                         * 2、如果此时创建的对象不为空，且不需要应用结果对象处理器，判断有没有延迟加载且具有嵌套查询的属性，如果有的话，则为对象创建一个代理，额外存储后面fetch的时候进行延迟加载所需的信息。返回对象。
                                                                         * 3、如果此时创建的对象不为空，且不需要应用结果对象处理器，如果对象需要自动映射，则先进行自动映射（创建自动映射列表的过程为：先找到在ResultSet、不在ResultMap中的列，如果在目标对象上可以找到属性且可以类型可以处理，则标记为可以自动映射；然后进行自动映射处理，如果遇到无法处理的属性，则根据autoMappingUnknownColumnBehavior进行处理，默认忽略），其次进行属性映射处理
                                                                         */
                                                                    --> Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);
                                                                        --> Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);
                                                                            --> final Class<?> resultType = resultMap.getType(); // class com.liang.User
                                                                            --> final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);
                                                                            --> return objectFactory.create(resultType);
                                                                                --> DefaultObjectFactory.create(java.lang.Class<T>, java.util.List<java.lang.Class<?>>, java.util.List<java.lang.Object>)
                                                                                    --> Class<?> classToCreate = resolveInterface(type);
                                                                                        --> if (type == List.class || type == Collection.class || type == Iterable.class) {
                                                                                              classToCreate = ArrayList.class;
                                                                                            } else if (type == Map.class) {
                                                                                              classToCreate = HashMap.class;
                                                                                            } else if (type == SortedSet.class) { // issue #510 Collections Support
                                                                                              classToCreate = TreeSet.class;
                                                                                            } else if (type == Set.class) {
                                                                                              classToCreate = HashSet.class;
                                                                                            } else {
                                                                                              classToCreate = type;
                                                                                            }

                                                                                    --> return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);
                                                                                        --> return constructor.newInstance(); // public com.liang.User()

                                                                        --> return resultObject;

                                                                        //里面包含originalObject 和objectWrapper 等信息,把rowValue进行了封装
                                                                    --> final MetaObject metaObject = configuration.newMetaObject(rowValue);

                                                                    --> foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || false;
                                                                        --> boolean foundValues = false;

                                                                        --> List<UnMappedColumnAutoMapping> autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);
                                                                            --> final String mapKey = resultMap.getId() + ":" + columnPrefix; //com.liang.UserMapper.baseResult:null
                                                                            --> List<UnMappedColumnAutoMapping> autoMapping = autoMappingsCache.get(mapKey);
                                                                            --> autoMappingsCache.put(mapKey, autoMapping);
                                                                            --> return autoMapping;

                                                                        --> return !autoMapping.isEmpty() || foundValues;

                                                                        // 处理属性映射,这里会识别出哪些属性需要nestQuery，哪些是nest ResultMap
                                                                    --> foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;
                                                                        --> final List<String> mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix); //[ID,USERNAME,PASSWORD]
                                                                        --> boolean foundValues = false;
                                                                        --> final List<ResultMapping> propertyMappings = resultMap.getPropertyResultMappings();
                                                                        --> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);
                                                                        --> Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);
                                                                            --> final TypeHandler<?> typeHandler = propertyMapping.getTypeHandler(); //class java.lang.String
                                                                            --> final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix); //id
                                                                            --> return typeHandler.getResult(rs, column);
                                                                                --> return rs.getString(columnName)

                                                                        --> final String property = propertyMapping.getProperty();

                                                                        --> foundValues = true;

                                                                        --> metaObject.setValue(property, value)

                                                                        --> return foundValues

                                                                    --> foundValues = lazyLoader.size() > 0 || foundValues;

                                                                    --> rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;

                                                                    --> return rowValue

                                                                --> storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);
                                                                        // 否则让ResultHander(默认是DefaultResultHander处理,直接添加到List<Object>中)
                                                                    --> callResultHandler(resultHandler, resultContext, rowValue);
                                                                        --> ((ResultHandler<Object>) resultHandler).handleResult(resultContext);
                                                                            --> List<Object> list = new ArrayList<>();
                                                                            --> list.add(rowValue);

                                                            //将结果集添加到multipleResults中
                                                        --> multipleResults.add(defaultResultHandler.getResultList());

                                                        // 循环直到处理完所有的结果集，一般情况下，一个execute只会返回一个结果集,除非语句比如存储过程返回多个resultSet
                                                    --> rsw = getNextResultSet(stmt);

                                                    --> return collapseSingleResultList(multipleResults);
                                                        --> return multipleResults.size() == 1 ? (List<Object>) multipleResults.get(0) : multipleResults;

                                    --> localCache.removeObject(key); // 1322964187:1136138037:com.liang.UserMapper.getUsers:0:2147483647:select id,username,password from user:development

                                    --> localCache.putObject(key, list);

                                    --> return list;


    --> UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        --> DefaultSqlSession.getMapper(interface com.liang.UserMapper)
            --> Configuration.getMapper(interface com.liang.UserMapper, DefaultSqlSession sqlSession)
                --> MapperRegistry.getMapper(interface com.liang.UserMapper,DefaultSqlSession sqlSession)
                    --> final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(interface com.liang.UserMapper);
                    --> return mapperProxyFactory.newInstance(sqlSession);
                        --> MapperProxyFactory.newInstance(sqlSession)
                            --> final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);
                                --> this.sqlSession = sqlSession;
                                    this.mapperInterface = mapperInterface;
                                    this.methodCache = methodCache;

                            --> return newInstance(mapperProxy);
                                --> return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);


    --> Map map = new HashMap<>();
        map.put("id","fdsafe2f2f2f2");
        map.put("flag","true");
        List<User> users = userMapper.getUserById(map);
            --> mapperProxy.invoke(Object proxy, Method method, Object[] args)
                --> final MapperMethod mapperMethod = cachedMapperMethod(method);
                    --> method = public abstract java.util.List com.liang.UserMapper.getUserById(java.util.Map)
                    --> value = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration())
                        --> this.command = new SqlCommand(config, mapperInterface, method);
                            --> final String methodName = method.getName(); // getUserById
                            --> final Class<?> declaringClass = method.getDeclaringClass(); // interface com.liang.UserMapper

                            --> MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,configuration);
                                --> String statementId = mapperInterface.getName() + "." + methodName; // com.liang.UserMapper.getUserById
                                --> return configuration.getMappedStatement(statementId)
                                    --> return configuration.getMappedStatement(id, true);
                                        --> buildAllStatements();
                                            --> parsePendingResultMaps()
                                                --> incompleteResultMaps.isEmpty() //将incompleteResultMaps中未初始化的进行初始化，如果都初始化完成了，就直接返回

                                        --> return mappedStatements.get(id);
                            --> this.name = ms.getId(); // com.liang.UserMapper.getUserById
                                this.type = ms.getSqlCommandType(); // SELECT

                        --> this.method = new MethodSignature(config, mapperInterface, method);
                            --> Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);
                                --> Type returnType = method.getGenericReturnType();  // java.util.List<com.liang.User>

                                --> Class<?> declaringClass = method.getDeclaringClass(); // interface com.liang.UserMapper

                                --> return resolveType(returnType, srcType, declaringClass);
                                    --> return resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);
                                        --> Class<?> rawType = (Class<?>) parameterizedType.getRawType(); // interface java.util.List
                                        --> Type[] typeArgs = parameterizedType.getActualTypeArguments(); // class com.liang.User
                                        --> return new ParameterizedTypeImpl(rawType, null, args)
                                            --> this.rawType = rawType;
                                                this.ownerType = ownerType;
                                                this.actualTypeArguments = actualTypeArguments;

                            --> this.returnType = (Class<?>) ((ParameterizedType) resolvedReturnType).getRawType();

                            --> this.returnsVoid = void.class.equals(this.returnType); //false

                            --> this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray(); // true

                            --> this.returnsCursor = Cursor.class.equals(this.returnType); // false

                            --> this.returnsOptional = Optional.class.equals(this.returnType); // false

                            --> this.mapKey = getMapKey(method);    // null

                            --> this.returnsMap = this.mapKey != null; // false

                            --> this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class); // null
                                --> final Class<?>[] argTypes = method.getParameterTypes(); // interface java.util.Map

                            --> this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class); // null
                                --> final Class<?>[] argTypes = method.getParameterTypes(); // interface java.util.Map

                            --> this.paramNameResolver = new ParamNameResolver(configuration, method);
                                --> final Class<?>[] paramTypes = method.getParameterTypes(); // interface java.util.Map
                                --> final SortedMap<Integer, String> map = new TreeMap<>();
                                --> String name = getActualParamName(method, paramIndex);  // name = arg0, paramIndex = 0
                                    --> return ParamNameUtil.getParamNames(method).get(paramIndex);
                                        --> return getParameterNames(method);
                                            --> return Arrays.stream(method.getParameters()).map(Parameter::getName).collect(Collectors.toList()); //["arg0"]
                                --> map.put(paramIndex, name) // paramIndex = 0 , name = arg0

                                --> SortedMap<Integer, String> names = Collections.unmodifiableSortedMap(map);


                    --> return methodCache.computeIfAbsent(method,value);

                --> return mapperMethod.execute(sqlSession, args); // args = HashMap
                    --> switch (this.command.getType())
                    --> case UPDATE|INSERT|DELETE:
                        --> 参见下面插入的例子
                    --> case SELECT:
                        --> Object result = executeForMany(sqlSession, args)
                            --> Object param = method.convertArgsToSqlCommandParam(args);   //param = HashMap
                                --> return paramNameResolver.getNamedParams(args);
                                    --> final int paramCount = names.size();
                                    --> return args[names.firstKey()]

                            --> result = sqlSession.selectList("com.liang.UserMapper.getUserById", param);
                                --> return this.selectList("com.liang.UserMapper.getUserById", parameter, RowBounds.DEFAULT);
                                    --> MappedStatement ms = configuration.getMappedStatement(statement);
                                    --> Object parameter = wrapCollection(parameter) //此处parameter是hashMap，不是collection
                                        --> if object instanceof Collection
                                            --> StrictMap<Object> map = new StrictMap<>();
                                                map.put("collection", object);
                                                if (object instanceof List) {
                                                  map.put("list", object);
                                                }
                                        --> if object.getClass().isArray()
                                            --> StrictMap<Object> map = new StrictMap<>();
                                                map.put("array", object);

                                    --> return executor.query(ms, parameter, rowBounds, Executor.NO_RESULT_HANDLER);
                                        --> CachingExecutor.query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)
                                            --> BoundSql boundSql = ms.getBoundSql(parameterObject);
                                                --> BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
                                                    --> DynamicSqlSource.getBoundSql(Object parameterObject)
                                                        --> DynamicContext context = new DynamicContext(configuration, parameterObject);
                                                            --> private final ContextMap bindings = new ContextMap(null, false);
                                                                --> this.parameterMetaObject = parameterMetaObject;
                                                                    this.fallbackParameterObject = fallbackParameterObject;
                                                            --> bindings.put(PARAMETER_OBJECT_KEY, parameterObject);  // key = _parameter; value = hashMap
                                                                bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId()); // key = _databaseId; value = null

                                                        --> rootSqlNode.apply(context);
                                                            --> List<SqlNode> contents
                                                            --> contents.forEach(node -> node.apply(context));
                                                                --> StaticTextSqlNode.apply(context)
                                                                    --> context.appendSql(text); //text = select id,username,password from user where 1=1
                                                                        --> stringBuilder.append(text)

                                                                --> IfSqlNode.apply(context) // 在会判断所有的if节点是否为真，如果为真，则把包含的sql语句进行拼接
                                                                    --> if (evaluator.evaluateBoolean(test, context.getBindings())) //test: flag == "true"
                                                                        --> ExpressionEvaluator.evaluateBoolean // 布尔表达式解析，对于返回值为数字的if表达式,0为假，非0为真
                                                                            --> Object value = OgnlCache.getValue(expression, parameterObject); //true 会通过ognl进行解析，然后得到是否为真的结果
                                                                                --> Map context = Ognl.createDefaultContext(root, MEMBER_ACCESS, CLASS_RESOLVER, null);
                                                                                --> return Ognl.getValue(parseExpression(expression), context, root); //expression: flag == "true"
                                                                                    --> Object node = expressionCache.get(expression);
                                                                                    --> node = Ognl.parseExpression(expression);
                                                                                    --> expressionCache.put(expression, node);
                                                                                    --> return node;
                                                                            --> return (Boolean) value;
                                                                    --> contents.apply(context)
                                                                        --> StaticTextSqlNode.apply(context)
                                                                            --> context.appendSql(text); //text: and id = #{id}
                                                                                --> stringBuilder.append(text)
                                                                    .
                                                                    .
                                                                    .

                                                        --> SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);
                                                            --> this.configuration = configuration;
                                                                this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
                                                                this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();

                                                        --> Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass() // class java.util.HashMap

                                                        --> SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());
                                                            --> ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);
                                                                --> this.parameterType = parameterType;
                                                                --> this.metaParameters = configuration.newMetaObject(additionalParameters);
                                                                    --> return MetaObject.forObject(additionalParameters, objectFactory, objectWrapperFactory, reflectorFactory);
                                                                        --> return new MetaObject(object, objectFactory, objectWrapperFactory, reflectorFactory);
                                                                            --> this.originalObject = object;
                                                                                this.objectFactory = objectFactory;
                                                                                this.objectWrapperFactory = objectWrapperFactory;
                                                                                this.reflectorFactory = reflectorFactory;
                                                                                this.objectWrapper = new MapWrapper(metaObject, (Map) object);
                                                                                    --> this.metaObject = metaObject;
                                                                                    --> this.map = map;

                                                            --> GenericTokenParser parser = new GenericTokenParser("#{", "}", handler);
                                                                --> this.openToken = openToken;
                                                                    this.closeToken = closeToken;
                                                                    this.handler = handler;

                                                            --> String sql = parser.parse(originalSql); // originalSql: select id,username,password from user where 1=1 and id = #{id}; sql: select id,username,password from user where 1=1 and id = ?
                                                                --> StringBuilder builder = new StringBuilder();
                                                                --> builder.append("select id,username,password from user where 1=1 and id = ");
                                                                --> builder.append(handler.handleToken(expression.toString())); // expression = id
                                                                    --> ParameterMappingTokenHandler.handleToken("id")
                                                                        --> (List<ParameterMapping>) parameterMappings.add(buildParameterMapping(content));
                                                                            --> Map<String, String> propertiesMap = parseParameterMapping(content); // key = property; value = id
                                                                            --> Class<?> propertyType = Object.class;
                                                                            --> ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType);
                                                                            --> for (Map.Entry<String, String> entry : propertiesMap.entrySet())
                                                                            --> if ("property".equals(name))   // name = property
                                                                                // Do Nothing

                                                                            --> return builder.build()
                                                                                --> resolveTypeHandler();
                                                                                    --> parameterMapping.typeHandler = typeHandlerRegistry.getTypeHandler("class java.lang.Object", null);
                                                                                --> validate()
                                                                                --> parameterMapping

                                                                        --> return "?"

                                                            --> return new StaticSqlSource(configuration, sql, handler.getParameterMappings());
                                                                --> this.sql = sql;
                                                                    this.parameterMappings = parameterMappings;
                                                                    this.configuration = configuration;

                                                        --> BoundSql boundSql = sqlSource.getBoundSql(parameterObject); // parameterObject = {flag:true,id:"fdsafe2f2f2f2"}
                                                            --> return new BoundSql(configuration, sql, parameterMappings, parameterObject);
                                                                --> this.sql = sql;
                                                                    this.parameterMappings = parameterMappings;
                                                                    this.parameterObject = parameterObject;
                                                                    this.additionalParameters = new HashMap<>();
                                                                    this.metaParameters = configuration.newMetaObject(additionalParameters);

                                                        --> return boundSql;

                                                --> List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();

                                                --> for (ParameterMapping pm : boundSql.getParameterMappings())

                                                --> String rmId = pm.getResultMapId(); // null

                                                --> return boundSql;


                                            --> CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
                                                --> simpleExecutor.createCacheKey(ms, parameterObject, rowBounds, boundSql)
                                                        // 根据映射语句id,分页信息,jdbc规范化的预编译sql,所有映射参数的值以及环境id的值,计算出缓存Key
                                                    --> CacheKey cacheKey = new CacheKey();  //-851223079:264257259:com.liang.UserMapper.getUserById:0:2147483647:select id,username,password from user where 1=1 and id = ?
                                                        cacheKey.update(ms.getId());
                                                        cacheKey.update(rowBounds.getOffset());
                                                        cacheKey.update(rowBounds.getLimit());
                                                        cacheKey.update(boundSql.getSql());

                                            --> return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);

                                                .
                                                .
                                                .
                                                //剩下的过程和查询列表的过程是差不多的，参看之前的分析过程

                            --> return result

    --> User user = new User();
        user.setId("1321ffaf22f3f35454");
        user.setUsername("ahahah");
        user.setPassword("ahahahha");

        userMapper.addUser(user);
            --> mapperProxy.invoke(Object proxy, Method method, Object[] args)
                --> final MapperMethod mapperMethod = cachedMapperMethod(method); // method= public abstract void com.liang.UserMapper.addUser(com.liang.User)
                    --> return methodCache.computeIfAbsent(method, k -> new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
                        --> this.command = new SqlCommand(config, mapperInterface, method);
                            this.method = new MethodSignature(config, mapperInterface, method);
                            .
                            .
                            .
                            //过程和查询的一样，区别是
                            this.name = ms.getId(); // com.liang.UserMapper.addUser
                            this.type = ms.getSqlCommandType(); // INSERT
                            this.returnType = void

                --> return mapperMethod.execute(sqlSession, args);
                    --> MapperMethod.execute(SqlSession sqlSession, Object[] args)
                        --> switch (command.getType())
                        --> case SELECT: // 上面有分析过程，一样
                        --> case INSERT|UPDATE|DELETE :
                            --> Object param = method.convertArgsToSqlCommandParam(args); //args = User{id='1321ffaf22f3f35454', username='ahahah', password='ahahahha'}
                                --> return paramNameResolver.getNamedParams(args); // return User{id='1321ffaf22f3f35454', username='ahahah', password='ahahahha'}

                            --> int num = sqlSession.insert("com.liang.UserMapper.addUser", param)
                                --> return update(statement, parameter);
                                    --> MappedStatement ms = configuration.getMappedStatement("com.liang.UserMapper.addUser");
                                        --> return mappedStatements.get(id);

                                    --> Object param = wrapCollection(parameter)
                                        --> return parameter  //User{id='1321ffaf22f3f35454', username='ahahah', password='ahahahha'}

                                    --> return executor.update(ms, param);
                                        --> CachingExecutor.update(MappedStatement ms, Object parameterObject)
                                            --> flushCacheIfRequired(ms);
                                                --> Cache cache = ms.getCache();
                                                --> TransactionalCacheManager.clear(cache)

                                            --> return simpleExecutor.update(ms, parameterObject);
                                                --> clearLocalCache();
                                                    --> PerpetualCache localCache.clear()
                                                    --> PerpetualCache localOutputParameterCache.clear();

                                                --> return doUpdate(ms, parameter);
                                                    --> Configuration configuration = ms.getConfiguration();

                                                    --> StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);
                                                        --> StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
                                                            --> switch (ms.getStatementType())
                                                            --> case PREPARED:
                                                                --> StatementHandler handler = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                                                                    --> this.configuration = mappedStatement.getConfiguration();
                                                                        this.executor = executor;
                                                                        this.mappedStatement = mappedStatement;
                                                                        this.rowBounds = rowBounds;
                                                                        this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();
                                                                        this.objectFactory = configuration.getObjectFactory();

                                                                        generateKeys(parameterObject);
                                                                            --> KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();

                                                                            --> keyGenerator.processBefore(executor, mappedStatement, null, parameter); // before key generator 主要用于oracle等使用序列机制的ID生成方式

                                                                        boundSql = mappedStatement.getBoundSql(parameterObject);
                                                                            --> BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
                                                                                --> return new BoundSql(configuration, sql, parameterMappings, parameterObject); //sql=insert into user (id,username,password) values (?,?,?); parameterMappings 中放置三个属性的list; parameterObject = User{id='1321ffaf22f3f35454', username='ahahah', password='ahahahha'}
                                                                            --> String rmId = pm.getResultMapId(); // 这里取的是resultMap 的id，因为是插入，没有resultMap，所以rmId是空的

                                                                            --> return boundSql;

                                                                        this.boundSql = boundSql;
                                                                        this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);
                                                                            --> ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
                                                                            --> parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler); // 为参数添加插件

                                                                            --> return parameterHandler;

                                                                        this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);

                                                                --> return handler

                                                        --> statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); // 为statementHandler添加插件

                                                        --> return statementHandler;

                                                    --> Statement stmt = prepareStatement(handler, ms.getStatementLog());
                                                        --> simpleExecutor.prepareStatement(StatementHandler handler, Log statementLog)
                                                            --> Connection connection = getConnection(statementLog); // 获取JDBC连接
                                                                .
                                                                .
                                                                //和之前获取连接的方式相同

                                                            --> stmt = handler.prepare(connection, transaction.getTimeout()); // 调用语句处理器的prepare方法
                                                                --> return preparedStatementHandler.prepare(connection, transactionTimeout);
                                                                        // 首先实例化语句，因为PREPARE和非PREPARE不同,所以留给具体子类实现
                                                                        // 不同类型语句的初始化过程不同,比如Statement语句直接调用JDBC java.sql.Connection.createStatement，
                                                                        // 而PrepareStatement则是调用java.sql.Connection.prepareStatement
                                                                    --> Statement statement = instantiateStatement(connection);
                                                                        --> String sql = boundSql.getSql();
                                                                        --> return connection.prepareStatement(sql);

                                                                    --> setStatementTimeout(statement, transactionTimeout); // 设置JDBC语句超时时间,注：数据库服务器端也可以设置语句超时时间。mysql通过参数max_statement_time设置,oracle截止12.2c不支持
                                                                        // 设置fetch大小
                                                                        // fetchSize设置每次从服务器端提取的行数,默认不同数据库实现不同,mysql一次性提取全部,oracle默认10。
                                                                        // 正确设置fetchSize可以避免OOM并且对性能有一定的影响,尤其是在网络延时较大的情况下
                                                                    --> setFetchSize(statement);

                                                                    --> return statement;

                                                            --> handler.parameterize(stmt); // 设置参数
                                                                --> preparedStatementHandler.parameterize(statement)
                                                                    --> parameterHandler.setParameters((PreparedStatement) statement);
                                                                        --> List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();

                                                                        --> ParameterMapping parameterMapping = parameterMappings.get(i);

                                                                        --> if (parameterMapping.getMode() != ParameterMode.OUT) //判断参数是输入还是输出

                                                                        --> String propertyName = parameterMapping.getProperty();

                                                                            // 计算参数值的优先级是 先判断是不是属于语句的AdditionalParameter；
                                                                            // 其次参数是不是null；然后判断是不是属于注册类型；
                                                                            // 都不是，那估计参数一定是object或者map了,这就要借助于MetaObject获取属性值了；
                                                                        --> MetaObject metaObject = configuration.newMetaObject(parameterObject);

                                                                        --> value = metaObject.getValue("id"); // value = 1321ffaf22f3f35454

                                                                        --> typeHandler.setParameter(ps, i + 1, value, jdbcType);
                                                                            --> setNonNullParameter(ps, i, parameter, jdbcType);
                                                                                --> ps.setString(i, parameter); // parameter = 1321ffaf22f3f35454

                                                            --> return stmt;

                                                    --> return handler.update(stmt);
                                                        --> return preparedStatementHandler.update(statement);
                                                            --> PreparedStatement ps = (PreparedStatement) statement;
                                                            --> ps.execute();
                                                                --> return method.invoke(statement, params);
                                                                    --> preparedStatement.execute()
                                                                        .
                                                                        .
                                                                        //执行的过程和之前是一样的

                                                            --> int rows = ps.getUpdateCount();

                                                            --> Object parameterObject = boundSql.getParameterObject();  // parameterObject = User{id='1321ffaf22f3f35454', username='ahahah', password='ahahahha'}

                                                            --> KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
                                                            --> keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject); // after key generator 主要用于mysql等使用自增机制的ID生成方式
                                                                --> Do Nothing
                                                            --> return rows; // 1

                            --> result = rowCountResult(num);
                                --> return num

                            --> return result;


    --> sqlSession.commit();
        --> DefaultSqlSession.commit(boolean)
            --> isCommit = isCommitOrRollbackRequired(force)
                --> return (!autoCommit && dirty) || force; //true
            --> executor.commit(isCommit);
                --> simpleExectore.commit(true)
                    --> flushStatements();
                    --> transaction.commit();
                        --> JdbcTransaction.commit
                            --> connection.commit();
                --> tcm.commit();
                    --> txCache.commit();
                        --> flushPendingEntries();
                            reset();

    --> sqlSession.close();























